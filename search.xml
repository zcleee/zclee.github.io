<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript混淆安全加固</title>
      <link href="/posts/2020-03-13-30733.html"/>
      <url>/posts/2020-03-13-30733.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在安全攻防战场中，前端代码都是公开的，那么对前端进行加密有意义吗？可能大部分人的回答是，<code>毫无意义</code>，不要自创加密算法，直接用HTTPS吧。但事实上，即使不了解密码学，也应知道是<code>有意义</code>的，因为<code>加密前</code>和<code>解密后</code>的环节，是不受保护的。HTTPS只能保护传输层，此外别无用处。</p><p>而加密环节又分：</p><ul><li>传输加密（对抗链路破解）</li><li>数据加密（对抗协议破解）</li><li>代码加密（隐藏算法、反调试…）</li></ul><p>本文主要列举一些我见到的，我想到的一些加密方式，其实确切的说，应该叫混淆，不应该叫加密。</p><p>那么，代码混淆的具体原理是什么？其实很简单，就是去除代码中尽可能多的有意义的信息，比如注释、换行、空格、代码负号、变量重命名、属性重命名（允许的情况下）、无用代码的移除等等。因为代码是公开的，我们必须承认没有任何一种算法可以完全不被破解，所以，我们只能尽可能增加攻击者阅读代码的成本。</p><p><a href="https://github.com/yacan8/blog/blob/master/posts/JavaScript%E6%B7%B7%E6%B7%86%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA.md" target="_blank" rel="noopener">原文链接</a></p><h2 id="语法树AST混淆"><a href="#语法树AST混淆" class="headerlink" title="语法树AST混淆"></a>语法树AST混淆</h2><p>在保证代码原本的功能性的情况下，我们可以对代码的AST按需进行变更，然后将变更后的AST在生成一份代码进行输出，达到混淆的目的，我们最常用的<a href="https://www.npmjs.com/package/uglify-js" target="_blank" rel="noopener">uglify-js</a>就是这样对代码进行混淆的，当然<code>uglify-js</code>的混淆只是主要进行代码压缩，即我们下面讲到的变量名混淆。</p><h3 id="变量名混淆"><a href="#变量名混淆" class="headerlink" title="变量名混淆"></a>变量名混淆</h3><p>将变量名混淆成阅读比较难阅读的字符，增加代码阅读难度，上面说的<code>uglify-js</code>进行的混淆，就是把变量混淆成了短名（主要是为了进行代码压缩），而现在大部分安全方向的混淆，都会将其混淆成类16进制变量名，效果如下：</p><pre><code class="js">var test = &#39;hello&#39;;</code></pre><p>混淆后：</p><pre><code class="js">var _0x7deb = &#39;hello&#39;;</code></pre><p>注意事项：</p><ol><li><p>eval语法，eval函数中可能使用了原来的变量名，如果不对其进行处理，可能会运行报错，如下：</p><pre><code class="js"> var test = &#39;hello&#39;; eval(&#39;console.log(test)&#39;);</code></pre><p> 如果不对eval中的console.log(test)进行关联的混淆，则会报错。不过，如果eval语法超出了静态分析的范畴，比如：</p><pre><code class="js"> var test = &#39;hello&#39;; var variableName = &#39;test&#39;; eval(&#39;console.log(&#39; + variableName + &#39;)&#39;);</code></pre><p> 这种咋办呢，可能要进行遍历AST找到其运行结果，然后在进行混淆，不过貌似成本比较高。</p></li><li><p>全局变量的编码，如果代码是作为SDK进行输出的，我们需要保存全局变量名的不变，比如：</p><pre><code class="html"> &lt;script&gt; var $ = function(id) {     return document.getElementById(id); }; &lt;/script&gt;</code></pre><p> <code>$</code>变量是放在全局下的，混淆过后如下：</p><pre><code class="html"> &lt;script&gt; var _0x6482fa = function(id) {     return document.getElementById(id); }; &lt;/script&gt;</code></pre><p> 那么如果依赖这一段代码的模块，使用<code>$(&#39;id&#39;)</code>调用自然会报错，因为这个全局变量已经被混淆了。</p></li></ol><h3 id="常量提取"><a href="#常量提取" class="headerlink" title="常量提取"></a>常量提取</h3><p>将JS中的常量提取到数组中，调用的时候用数组下标的方式调用，这样的话直接读懂基本不可能了，要么反AST处理下，要么一步一步调试，工作量大增。</p><p>以上面的代码为例：</p><pre><code class="js">var test = &#39;hello&#39;;</code></pre><p>混淆过后：</p><pre><code class="js">var _0x9d2b = [&#39;hello&#39;];var _0xb7de = function (_0x4c7513) {    var _0x96ade5 = _0x9d2b[_0x4c7513];    return _0x96ade5;};var test = _0xb7de(0);</code></pre><p>当然，我们可以根据需求，将数组转化为二位数组、三维数组等，只需要在需要用到的地方获取就可以。</p><h3 id="常量混淆"><a href="#常量混淆" class="headerlink" title="常量混淆"></a>常量混淆</h3><p>将常量进行加密处理，上面的代码中，虽然已经是混淆过后的代码了，但是<code>hello</code>字符串还是以明文的形式出现在代码中，可以利用JS中16进制编码会直接解码的特性将关键字的Unicode进行了16进制编码。如下：</p><pre><code class="js">var test = &#39;hello&#39;;</code></pre><p>结合常量提取得到混淆结果：</p><pre><code class="js">var _0x9d2b = [&#39;\x68\x65\x6c\x6c\x6f&#39;];var _0xb7de = function (_0x4c7513) {    _0x4c7513 = _0x4c7513 - 0x0;    var _0x96ade5 = _0x9d2b[_0x4c7513];    return _0x96ade5;};var test = _0xb7de(&#39;0x0&#39;);</code></pre><p>当然，除了JS特性自带的Unicode自动解析以外，也可以自定义一些加解密算法，比如对常量进行base64编码，或者其他的什么rc4等等，只需要使用的时候解密就OK，比如上面的代码用base64编码后：</p><pre><code class="js">var _0x9d2b = [&#39;aGVsbG8=&#39;]; // base64编码后的字符串var _0xaf421 = function (_0xab132) {    // base64解码函数    var _0x75aed = function(_0x2cf82) {        // TODO: 解码    };    return _0x75aed(_0xab132);}var _0xb7de = function (_0x4c7513) {    _0x4c7513 = _0x4c7513 - 0x0;    var _0x96ade5 = _0xaf421(_0x9d2b[_0x4c7513]);    return _0x96ade5;};var test = _0xb7de(&#39;0x0&#39;);</code></pre><h3 id="运算混淆"><a href="#运算混淆" class="headerlink" title="运算混淆"></a>运算混淆</h3><p>将所有的逻辑运算符、二元运算符都变成函数，目的也是增加代码阅读难度，让其无法直接通过静态分析得到结果。如下：</p><pre><code class="js">var i = 1 + 2;var j = i * 2;var k = j || i;</code></pre><p>混淆后：</p><pre><code class="js">var _0x62fae = {    _0xeca4f: function(_0x3c412, _0xae362) {        return _0x3c412 + _0xae362;    },    _0xe82ae: function(_0x63aec, _0x678ec) {        return _0x63aec * _0x678ec;    },    _0x2374a: function(_0x32487, _0x3a461) {        return _0x32487 || _0x3a461;    }};var i = _0x62fae._0e8ca4f(1, 2);var j = _0x62fae._0xe82ae(p1, 2);var k = _0x62fae._0x2374a(i, j);</code></pre><p>当然除了逻辑运算符和二元运算符以外，还可以将函数调用、静态字符串进行类似的混淆，如下：</p><pre><code class="js">var fun1 = function(name) {    console.log(&#39;hello, &#39; + name);};var fun2 = function(name, age) {    console.log(name + &#39; is &#39; + age + &#39; years old&#39;);}var name = &#39;xiao.ming&#39;;fun1(name);fun2(name, 8);</code></pre><pre><code class="js">var _0x62fae = {    _0xe82ae: function(_0x63aec, _0x678ec) {        return _0x63aec(_0x678ec);    },    _0xeca4f: function(_0x92352, _0x3c412, _0xae362) {        return _0x92352(_0x3c412, _0xae362)    },    _0x2374a: &#39;xiao.ming&#39;,    _0x5482a: &#39;hello, &#39;,    _0x837ce: &#39; is &#39;,    _0x3226e: &#39; years old&#39;};var fun1 = function(name) {    console.log(_0x62fae._0x5482a + name);};var fun2 = function(name, age) {    console.log(name + _0x62fae._0x837ce + age + _0x62fae._0x3226e);}var name = _0x62fae._0x2374a;_0x62fae._0xe82ae(name);_0x62fae._0x2374a(name, 0x8);</code></pre><p>上面的例子中，fun1和fun2内的字符串相加也会被混淆走，静态字符串也会被前面提到的<code>字符串提取</code>抽取到数组中（我就是懒，这部分代码就不写了）。</p><p>需要注意的是，我们每次遇到相同的运算符，需不需要重新生成函数进行替换，这就按个人需求了。</p><h3 id="语法丑化"><a href="#语法丑化" class="headerlink" title="语法丑化"></a>语法丑化</h3><p>将我们常用的语法混淆成我们不常用的语法，前提是不改变代码的功能。例如for换成do/while，如下：</p><pre><code class="js">for (i = 0; i &lt; n; i++) {    // TODO: do something}var i = 0;do {    if (i &gt;= n) break;    // TODO: do something    i++;} while (true)</code></pre><h3 id="动态执行"><a href="#动态执行" class="headerlink" title="动态执行"></a>动态执行</h3><p>将静态执行代码添加动态判断，运行时动态决定运算符，干扰静态分析。</p><p>如下：</p><pre><code class="js">var c = 1 + 2;</code></pre><p>混淆过后：</p><pre><code class="js">function _0x513fa(_0x534f6, _0x85766) { return _0x534f6 + _0x85766; }function _0x3f632(_0x534f6, _0x534f6) { return _0x534f6 - _0x534f6; }// 动态判定函数function _0x3fa24() {    return true;}var c = _0x3fa24() ? : _0x513fa(1, 2) : _0x3f632(1, 2);</code></pre><h3 id="流程混淆"><a href="#流程混淆" class="headerlink" title="流程混淆"></a>流程混淆</h3><p>对执行流程进行混淆，又称控制流扁平化，为什么要做混淆执行流程呢？因为在代码开发的过程中，为了使代码逻辑清晰，便于维护和扩展，会把代码编写的逻辑非常清晰。一段代码从输入，经过各种if/else分支，顺序执行之后得到不同的结果，而我们需要将这些执行流程和判定流程进行混淆，让攻击者没那么容易摸清楚我们的执行逻辑。</p><p>控制流扁平化又分顺序扁平化、条件扁平化，</p><h4 id="顺序扁平化"><a href="#顺序扁平化" class="headerlink" title="顺序扁平化"></a>顺序扁平化</h4><p>顾名思义，将按顺序、自上而下执行的代码，分解成数个分支进行执行，如下代码：</p><pre><code class="js">(function () {    console.log(1);    console.log(2);    console.log(3);    console.log(4);    console.log(5);})();</code></pre><p>流程图如下：</p><p><img src="/images/posts/ControlFlowFlattening3.jpeg" alt="控制流扁平化3"></p><p>混淆过后代码如下：</p><pre><code class="js">(function () {    var flow = &#39;3|4|0|1|2&#39;.split(&#39;|&#39;), index = 0;    while (!![]) {        switch (flow[index++]) {        case &#39;0&#39;:            console.log(3);            continue;        case &#39;1&#39;:            console.log(4);            continue;        case &#39;2&#39;:            console.log(5);            continue;        case &#39;3&#39;:            console.log(1);            continue;        case &#39;4&#39;:            console.log(2);            continue;        }        break;    }}());</code></pre><p>混淆过后的流程图如下：</p><p><img src="/images/posts/ControlFlowFlattening4.jpeg" alt="控制流扁平化4"></p><p>流程看起来<code>扁</code>了。</p><h4 id="条件扁平化"><a href="#条件扁平化" class="headerlink" title="条件扁平化"></a>条件扁平化</h4><p>条件扁平化的作用是把所有if/else分支的流程，全部扁平到一个流程中，在流程图中拥有相同的入口和出口。</p><p>如下面的代码：</p><pre><code class="js">function modexp(y, x, w, n) {    var R, L;    var k = 0;    var s = 1;    while(k &lt; w) {        if (x[k] == 1) {            R = (s * y) % n;        }        else {            R = s;        }        s = R * R % n;        L = R;        k++;    }    return L;}</code></pre><p>如上代码，流程图是这样的</p><p><img src="/images/posts/ControlFlowFlattening1.jpeg" alt="控制流扁平化1"></p><p>控制流扁平化后代码如下：</p><pre><code class="js">function modexp(y, x, w, n) {    var R, L, s, k;    var next = 0;    for(;;) {        switch(next) {        case 0: k = 0; s = 1; next = 1; break;        case 1: if (k &lt; w) next = 2; else next = 6; break;        case 2: if (x[k] == 1) next = 3; else next = 4; break;        case 3: R = (s * y) % n; next = 5; break;        case 4: R = s; next = 5; break;        case 5: s = R * R % n; L = R; k++; next = 1; break;        case 6: return L;        }    }}</code></pre><p>混淆后的流程图如下：</p><p><img src="/images/posts/ControlFlowFlattening2.jpeg" alt="控制流扁平化2"></p><p>直观的感觉就是代码变<code>扁</code>了，所有的代码都挤到了一层当中，这样做的好处在于在让攻击者无法直观，或通过静态分析的方法判断哪些代码先执行哪些后执行，必须要通过动态运行才能记录执行顺序，从而加重了分析的负担。</p><p>需要注意的是，在我们的流程中，无论是顺序流程还是条件流程，如果出现了块作用域的变量声明(const/let)，那么上面的流程扁平化将会出现错误，因为switch/case内部为块作用域，表达式被分到case内部之后，其他case无法取到const/let的变量声明，自然会报错。</p><h4 id="不透明谓词"><a href="#不透明谓词" class="headerlink" title="不透明谓词"></a>不透明谓词</h4><p>上面的switch/case的判断是通过数字（也就是谓词）的形式判断的，而且是透明的，可以看到的，为了更加的混淆视听，可以将case判断设定为表达式，让其无法直接判断，比如利用上面代码，改为不透明谓词：</p><pre><code class="js">function modexp(y, x, w, n) {    var a = 0, b = 1, c = 2 * b + a;    var R, L, s, k;    var next = 0;    for(;;) {        switch(next) {        case (a * b): k = 0; s = 1; next = 1; break;        case (2 * a + b): if (k &lt; w) next = 2; else next = 6; break;        case (2 * b - a): if (x[k] == 1) next = 3; else next = 4; break;        case (3 * a + b + c): R = (s * y) % n; next = 5; break;        case (2 * b + c): R = s; next = 5; break;        case (2 * c + b): s = R * R % n; L = R; k++; next = 1; break;        case (4 * c - 2 * b): return L;        }    }}</code></pre><p>谓词用a、b、c三个变量组成，甚至可以把这三个变量隐藏到全局中定义，或者隐藏在某个数组中，让攻击者不能那么轻易找到。</p><h3 id="脚本加壳"><a href="#脚本加壳" class="headerlink" title="脚本加壳"></a>脚本加壳</h3><p>将脚本进行编码，运行时 解码 再 eval 执行如：</p><pre><code>eval (…………………………..……………. ……………. !@#$%^&amp;* ……………. .…………………………..……………. )</code></pre><p>但是实际上这样意义并不大，因为攻击者只需要把alert或者console.log就原形毕露了</p><p>改进方案：利用<code>Function / (function(){}).constructor</code>将代码当做字符串传入，然后执行，如下：</p><pre><code class="js">var code = &#39;console.log(&quot;hellow&quot;)&#39;;(new Function(code))();</code></pre><p>如上代码，可以对code进行加密混淆，例如<a href="http://utf-8.jp/public/aaencode.html" target="_blank" rel="noopener">aaencode</a>，原理也是如此，我们举个例子</p><pre><code class="js">alert(&quot;Hello, JavaScript&quot;);</code></pre><p>利用aaencode混淆过后，代码如下：</p><pre><code>ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ [&#39;_&#39;]; o=(ﾟｰﾟ)  =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)={ﾟΘﾟ: &#39;_&#39; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&#39;_&#39;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &#39;_&#39;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&#39;_&#39;)[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&#39;_&#39;) [c^_^o];(ﾟДﾟ) [&#39;c&#39;] = ((ﾟДﾟ)+&#39;_&#39;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&#39;o&#39;] = ((ﾟДﾟ)+&#39;_&#39;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [&#39;c&#39;]+(ﾟДﾟ) [&#39;o&#39;]+(ﾟωﾟﾉ +&#39;_&#39;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&#39;_&#39;) [ﾟｰﾟ] + ((ﾟДﾟ) +&#39;_&#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&#39;_&#39;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&#39;c&#39;]+((ﾟДﾟ)+&#39;_&#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&#39;o&#39;]+((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ];(ﾟДﾟ) [&#39;_&#39;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&#39;_&#39;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&#39;_&#39;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +&#39;_&#39;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&#39;_&#39;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&#39;\\&#39;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +&#39;_&#39;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=&#39;\&quot;&#39;;(ﾟДﾟ) [&#39;_&#39;] ( (ﾟДﾟ) [&#39;_&#39;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&#39;_&#39;);</code></pre><p>这段代码看起来很奇怪，不像是JavaScript代码，但是实际上这段代码是用一些看似表情的符号，声明了一个16位的数组（用来表示16进制位置），然后将code当做字符串遍历，把每个代码符号通过<code>string.charCodeAt</code>取这个16位的数组下标，拼接成代码。大概的意思就是把代码当做字符串，然后使用这些符号的拼接代替这一段代码（可以看到代码里有很多加号），最后，通过<code>(new Function(code))(&#39;_&#39;)</code>执行。</p><p>仔细观察上面这一段代码，把代码最后的<code>(&#39;_&#39;)</code>去掉，在运行，你会直接看到源代码，然后<code>Function.constructor</code>存在<code>(ﾟДﾟ)</code>变量中，感兴趣的同学可以自行查看。</p><p>除了aaencode，<a href="http://utf-8.jp/public/jjencode.html" target="_blank" rel="noopener">jjencode</a>原理也是差不多，就不做解释了，其他更霸气的<a href="http://www.jsfuck.com/" target="_blank" rel="noopener">jsfuck</a>，这些都是对代码进行加密的，这里就不详细介绍了。</p><h2 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h2><p>由于JavaScript自带<code>debugger</code>语法，我们可以利用死循环性的<code>debugger</code>，当页面打开调试面板的时候，无限进入调试状态。</p><h3 id="定时执行"><a href="#定时执行" class="headerlink" title="定时执行"></a>定时执行</h3><p>在代码开始执行的时候，使用<code>setInterval</code>定时触发我们的反调试函数。</p><h3 id="随机执行"><a href="#随机执行" class="headerlink" title="随机执行"></a>随机执行</h3><p>在代码生成阶段，随机在部分函数体中注入我们的反调试函数，当代码执行到特定逻辑的时候，如果调试面板在打开状态，则无限进入调试状态。</p><h2 id="内容监测"><a href="#内容监测" class="headerlink" title="内容监测"></a>内容监测</h2><p>由于我们的代码可能已经反调试了，攻击者可以会将代码拷贝到自己本地，然后修改，调试，执行，这个时候就需要添加一些检测进行判定，如果不是正常的环境执行，那让代码自行失败。</p><h3 id="代码自检"><a href="#代码自检" class="headerlink" title="代码自检"></a>代码自检</h3><p>在代码生成的时候，为函数生成一份Hash，在代码执行之前，通过函数 toString 方法，检测代码是否被篡改</p><pre><code class="js">function module() {    // 篡改校验    if (Hash(module.toString()) != &#39;JkYxnHlxHbqKowiuy&#39;) {        // 代码被篡改！    }}</code></pre><h3 id="环境自检"><a href="#环境自检" class="headerlink" title="环境自检"></a>环境自检</h3><p>检查当前脚本的执行环境，例如当前的URL是否在允许的白名单内、当前环境是否正常的浏览器。</p><p>如果为Nodejs环境，如果出现异常环境，甚至我们可以启动木马，长期跟踪。</p><h2 id="废代码注入"><a href="#废代码注入" class="headerlink" title="废代码注入"></a>废代码注入</h2><p>插入一些永远不会发生的代码，让攻击者在分析代码的时候被这些无用的废代码混淆视听，增加阅读难度。</p><h3 id="废逻辑注入"><a href="#废逻辑注入" class="headerlink" title="废逻辑注入"></a>废逻辑注入</h3><p>与废代码相对立的就是有用的代码，这些有用的代码代表着被执行代码的逻辑，这个时候我们可以收集这些逻辑，增加一段判定来决定执行真逻辑还是假逻辑，如下：</p><pre><code class="js">(function(){    if (true) {        var foo = function () {            console.log(&#39;abc&#39;);        };        var bar = function () {            console.log(&#39;def&#39;);        };        var baz = function () {            console.log(&#39;ghi&#39;);        };        var bark = function () {            console.log(&#39;jkl&#39;);        };        var hawk = function () {            console.log(&#39;mno&#39;);        };        foo();        bar();        baz();        bark();        hawk();    }})();</code></pre><p>可以看到，所有的console.log都是我们的执行逻辑，这个时候可以收集所有的console.log，然后制造假判定来执行真逻辑代码，收集逻辑注入后如下：</p><pre><code class="js">(function(){    if (true) {        var foo = function () {            if (&#39;aDas&#39; === &#39;aDas&#39;) {                console.log(&#39;abc&#39;);            } else {                console.log(&#39;def&#39;);            }        };        var bar = function () {            if (&#39;Mfoi&#39; !== &#39;daGs&#39;) {                console.log(&#39;ghi&#39;);            } else {                console.log(&#39;def&#39;);            }        };        var baz = function () {            if (&#39;yuHo&#39; === &#39;yuHo&#39;) {                console.log(&#39;ghi&#39;);            } else {                console.log(&#39;abc&#39;);            }        };        var bark = function () {            if (&#39;qu2o&#39; === &#39;qu2o&#39;) {                console.log(&#39;jkl&#39;);            } else {                console.log(&#39;mno&#39;);            }        };        var hawk = function () {            if (&#39;qCuo&#39; !== &#39;qcuo&#39;) {                console.log(&#39;jkl&#39;);            } else {                console.log(&#39;mno&#39;);            }        };        foo();        bar();        baz();        bark();        hawk();    }})();</code></pre><p>判定逻辑中生成了一些字符串，在没有使用字符串提取的情况下，这是可以通过代码静态分析来得到真实的执行逻辑的，或者我们可以使用上文讲到的动态执行来决定执行真逻辑，可以看一下使用字符串提取和变量名编码后的效果，如下：</p><pre><code class="js">var _0x6f5a = [    &#39;abc&#39;,    &#39;def&#39;,    &#39;caela&#39;,    &#39;hmexe&#39;,    &#39;ghi&#39;,    &#39;aaeem&#39;,    &#39;maxex&#39;,    &#39;mno&#39;,    &#39;jkl&#39;,    &#39;ladel&#39;,    &#39;xchem&#39;,    &#39;axdci&#39;,    &#39;acaeh&#39;,    &#39;log&#39;];(function (_0x22c909, _0x4b3429) {    var _0x1d4bab = function (_0x2e4228) {        while (--_0x2e4228) {            _0x22c909[&#39;push&#39;](_0x22c909[&#39;shift&#39;]());        }    };    _0x1d4bab(++_0x4b3429);}(_0x6f5a, 0x13f));var _0x2386 = function (_0x5db522, _0x143eaa) {    _0x5db522 = _0x5db522 - 0x0;    var _0x50b579 = _0x6f5a[_0x5db522];    return _0x50b579;};(function () {    if (!![]) {        var _0x38d12d = function () {            if (_0x2386(&#39;0x0&#39;) !== _0x2386(&#39;0x1&#39;)) {                console[_0x2386(&#39;0x2&#39;)](_0x2386(&#39;0x3&#39;));            } else {                console[_0x2386(&#39;0x2&#39;)](_0x2386(&#39;0x4&#39;));            }        };        var _0x128337 = function () {            if (_0x2386(&#39;0x5&#39;) !== _0x2386(&#39;0x6&#39;)) {                console[_0x2386(&#39;0x2&#39;)](_0x2386(&#39;0x4&#39;));            } else {                console[_0x2386(&#39;0x2&#39;)](_0x2386(&#39;0x7&#39;));            }        };        var _0x55d92e = function () {            if (_0x2386(&#39;0x8&#39;) !== _0x2386(&#39;0x8&#39;)) {                console[_0x2386(&#39;0x2&#39;)](_0x2386(&#39;0x3&#39;));            } else {                console[_0x2386(&#39;0x2&#39;)](_0x2386(&#39;0x7&#39;));            }        };        var _0x3402dc = function () {            if (_0x2386(&#39;0x9&#39;) !== _0x2386(&#39;0x9&#39;)) {                console[_0x2386(&#39;0x2&#39;)](_0x2386(&#39;0xa&#39;));            } else {                console[_0x2386(&#39;0x2&#39;)](_0x2386(&#39;0xb&#39;));            }        };        var _0x28cfaa = function () {            if (_0x2386(&#39;0xc&#39;) === _0x2386(&#39;0xd&#39;)) {                console[_0x2386(&#39;0x2&#39;)](_0x2386(&#39;0xb&#39;));            } else {                console[_0x2386(&#39;0x2&#39;)](_0x2386(&#39;0xa&#39;));            }        };        _0x38d12d();        _0x128337();        _0x55d92e();        _0x3402dc();        _0x28cfaa();    }}());</code></pre><h3 id="求值陷阱"><a href="#求值陷阱" class="headerlink" title="求值陷阱"></a>求值陷阱</h3><p>除了注入执行逻辑以外，还可以埋入一个隐蔽的陷阱，在一个<code>永不到达</code>且<code>无法静态分析</code>的分支里，引用该函数，正常用户不会执行，而 AST 遍历求值时，则会触发陷阱！陷阱能干啥呢？</p><ul><li>日志上报，及时了解情况</li><li>在本地存储隐写特征，长期跟踪</li><li>释放CSRF漏洞，获得破解者的详细信息</li><li>开启自杀程序（页面崩溃、死循环、耗尽内存等）</li></ul><h3 id="加壳干扰"><a href="#加壳干扰" class="headerlink" title="加壳干扰"></a>加壳干扰</h3><p>在代码用eval包裹，然后对eval参数进行加密，并埋下陷阱，在解码时插入无用代码，干扰显示，大量换行、注释、字符串等大量特殊字符，导致显示卡顿。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>大概我想到的混淆就包括这些，单个特性使用的话，混淆效果一般，各个特性组合起来用的话，最终效果很明显，当然这个看个人需求，毕竟混淆是个双刃剑，在增加了阅读难度的同时，也增大了脚本的体积，降低了代码的运行效率。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/ichunqiu/p/7383045.html" target="_blank" rel="noopener">代码混淆之道——控制流扁平与不透明谓词理论篇</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> AST </tag>
            
            <tag> 混淆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在前端页面中使用@font-face来显示web自定义字体</title>
      <link href="/posts/2020-02-11-748.html"/>
      <url>/posts/2020-02-11-748.html</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.w3.org/TR/css3-fonts/" target="_blank" rel="noopener">@font-face</a>是<a href="http://www.w3.org/TR/CSS/#css3" target="_blank" rel="noopener">CSS3</a>中的一个模块，他主要是把自己定义的Web字体嵌入到你的网页中，随着<a href="http://www.w3.org/TR/css3-fonts/" target="_blank" rel="noopener">@font-face</a>模块的出现，我们在Web的开发中使用字体不怕只能使用Web安全字体，你们当中或许有许多人会不自然的问，这样的东西IE能支持吗？当我告诉大家<a href="http://www.w3.org/TR/css3-fonts/" target="_blank" rel="noopener">@font-face</a>这个功能早在IE4就支持了你肯定会感到惊讶。我的Blog就使用了许多这样的自定义Web字体，比如说首页的Logo，Tags以及页面中的手写英文体，很多朋友问我如何使用，能让自己的页面也支持这样的自定义字体，一句话这些都是<a href="http://www.w3.org/TR/css3-fonts/" target="_blank" rel="noopener">@font-face</a>实现的，为了能让更多的朋友知道如何使用他，今天我主要把自己的一点学习过程贴上来和大家分享。</p><p>首先我们一起来看看@font-face的语法规则：</p><pre><code class="css">@font-face {   font-family: &lt;YourWebFontName&gt;;   src: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*;   [font-weight: &lt;weight&gt;];   [font-style: &lt;style&gt;]; }</code></pre><p><strong>取值说明</strong></p><p>1、YourWebFontName:此值指的就是你自定义的字体名称，最好是使用你下载的默认字体，他将被引用到你的Web元素中的font-family。如“font-family:”YourWebFontName”;”</p><p>2、source:此值指的是你自定义的字体的存放路径，可以是相对路径也可以是绝路径；</p><p>3、format：此值指的是你自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型：truetype,opentype,truetype-aat,embedded-opentype,avg等；</p><p>4、weight和style:这两个值大家一定很熟悉，weight定义字体是否为粗体，style主要定义字体样式，如斜体。</p><p><strong>兼容浏览器</strong></p><p><img src="/images/posts/font-face-browers.jpg" alt=""></p><p>说到浏览器对@font-face的兼容问题，这里涉及到一个字体format的问题，因为不同的浏览器对字体格式支持是不一致的，这样大家有必要了解一下，各种版本的浏览器支持什么样的字体，前面也简单带到了有关字体的几种格式，下面我就分别说一下这个问题，让大家心里有一个概念：</p><p><strong>一、TureTpe(.ttf)格式：</strong></p><p>.ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，因此他不为网站优化,支持这种字体的浏览器有【IE9+,Firefox3.5+,Chrome4+,Safari3+,Opera10+,iOS Mobile Safari4.2+】；</p><p><strong>二、OpenType(.otf)格式：</strong></p><p>.otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，所以也提供了更多的功能,支持这种字体的浏览器有【Firefox3.5+,Chrome4.0+,Safari3.1+,Opera10.0+,iOS Mobile Safari4.2+】；</p><p><strong>三、Web Open Font Format(.woff)格式：</strong></p><p>.woff字体是Web字体中最佳格式，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离,支持这种字体的浏览器有【IE9+,Firefox3.5+,Chrome6+,Safari3.6+,Opera11.1+】；</p><p><strong>四、Embedded Open Type(.eot)格式：</strong></p><p>.eot字体是IE专用字体，可以从TrueType创建此格式字体,支持这种字体的浏览器有【IE4+】；</p><p><strong>五、SVG(.svg)格式：</strong></p><p>.svg字体是基于SVG字体渲染的一种格式,支持这种字体的浏览器有【Chrome4+,Safari3.1+,Opera10.0+,iOS Mobile Safari3.2+】。</p><p>这就意味着在@font-face中我们至少需要.woff,.eot两种格式字体，甚至还需要.svg等字体达到更多种浏览版本的支持。</p><p>为了使@font-face达到更多的浏览器支持，<a href="http://paulirish.com/" target="_blank" rel="noopener">Paul Irish</a>写了一个独特的@font-face语法叫<a href="http://paulirish.com/2009/bulletproof-font-face-implementation-syntax/" target="_blank" rel="noopener">Bulletproof @font-face</a>:</p><pre><code class="css">@font-face { font-family: &#39;YourWebFontName&#39;; src: url(&#39;YourWebFontName.eot?&#39;) format(&#39;eot&#39;);/*IE*/ src:url(&#39;YourWebFontName.woff&#39;) format(&#39;woff&#39;), url(&#39;YourWebFontName.ttf&#39;) format(&#39;truetype&#39;);/*non-IE*/}</code></pre><p>但为了让各多的浏览器支持，你也可以写成：</p><pre><code class="css">@font-face { font-family: &#39;YourWebFontName&#39;; src: url(&#39;YourWebFontName.eot&#39;); /* IE9 Compat Modes */ src: url(&#39;YourWebFontName.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;), /* IE6-IE8 */          url(&#39;YourWebFontName.woff&#39;) format(&#39;woff&#39;), /* Modern Browsers */          url(&#39;YourWebFontName.ttf&#39;)  format(&#39;truetype&#39;), /* Safari, Android, iOS */          url(&#39;YourWebFontName.svg#YourWebFontName&#39;) format(&#39;svg&#39;); /* Legacy iOS */}</code></pre><p>说了这么多空洞的理论知识，大家一定有点心痒痒了，那么我们先来看看W3CPLUS首页中导航部分的兰色字体是如何实现的，假如我们有一个这样的DOM标签，需要应用自定义字体：</p><p><strong>HTML Code:</strong></p><pre><code class="css"> &lt;h2 class=&quot;neuesDemo&quot;&gt;Neues Bauen Demo&lt;/h2&gt;</code></pre><p>通过@font-face来定义自己的Web Font:</p><pre><code class="css">@font-face {  font-family: &#39;NeuesBauenDemo&#39;;  src: url(&#39;../fonts/neues_bauen_demo-webfont.eot&#39;);  src: url(&#39;../fonts/neues_bauen_demo-webfont.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),   url(&#39;../fonts/neues_bauen_demo-webfont.woff&#39;) format(&#39;woff&#39;),   url(&#39;../fonts/neues_bauen_demo-webfont.ttf&#39;) format(&#39;truetype&#39;),   url(&#39;../fonts/neues_bauen_demo-webfont.svg#NeuesBauenDemo&#39;) format(&#39;svg&#39;);  font-weight: normal;  font-style: normal;}</code></pre><p>我在这里采用的是相对路径，当然大家也可以使用绝路径。到这里我们就需要把定义好的字体应用到我们实际页面中去：</p><pre><code class="css">h2.neuesDemo {   font-family: &#39;NeuesBauenDemo&#39;}</code></pre><p><strong>效果：</strong></p><p><img src="/images/posts/neues-bauen-demo.jpg" alt=""></p><p>看到上面的效果，我想大家会感到@font-face很神奇，同时也想争着做做看，可是一动手才发现，特殊字体我要怎样才能得到，那些.eot,.woff,.ttf,.svg这些字体格式又怎么获取呢？有些朋友可能就不知道如何运手了，那么我们就带着这些问题来一个全程完成的实例吧：</p><p><strong>一、获取特殊字体：</strong></p><p>我们拿下面这种single Malta字体来说吧：</p><p><img src="/images/posts/font-face-single-malta-demo.jpg" alt=""></p><p>要得到single Malta字体，不外乎两种途径，其一找到付费网站购买字体，其二就是到免费网站DownLoad字体。当然要给钱的这种傻事我想大家都不会做的，那我们就得到免费的地方下载，在哪有呢？我平时都是到<a href="http://www.google.com/webfonts" target="_blank" rel="noopener">Google Web Fonts</a>和<a href="http://www.dafont.com/" target="_blank" rel="noopener">Dafont.com</a>寻找自己需要的字体，当然网上也还有别的下载字体的地方，这个Demo使用的是<a href="http://www.dafont.com/" target="_blank" rel="noopener">Dafont.com</a>的Single Malta字体，这样就可以到这里下载<a href="http://www.dafont.com/single-malta.font" target="_blank" rel="noopener">Single Malta</a>：</p><p><img src="/images/posts/single-malta-font.jpg" alt=""></p><p>Single Malta下载下来后，需要把它解压缩出来：</p><p><img src="/images/posts/single-malta-font-out.jpg" alt=""></p><p><strong>二、获取@font-face所需字体格式：</strong></p><p>特殊字体已经在你的电脑中了，现在我们需要想办法获得@font-face所需的.eot,.woff,.ttf,.svg字体格式。要获取这些字体格式，我们同样是需要第三方工具或者软件来实现，下面我给大家推荐一款我常用的一个工具<a href="http://www.fontsquirrel.com/fontface/generator" target="_blank" rel="noopener">fontsquirrel</a>,别的先不多说，首跟我点<a href="http://www.fontsquirrel.com/fontface/generator" target="_blank" rel="noopener">这里</a>进入到下面这个界面吧。</p><p><img src="/images/posts/font-face-kit-generator.png" alt=""></p><p>如果你进入页面没有看到上图，你可以直接点击导航:</p><p><img src="/images/posts/fontsquirrel-menu.jpg" alt=""></p><p>如果你看到了上面的界面，那就好办了，我们来看如何应用这个工具生成@font-face需要的各种字体，先把我们刚才下载的字体上传上去：</p><p><img src="/images/posts/add-fonts.jpg" alt=""></p><p>上传后按下图所示操作：</p><p><img src="/images/posts/font-download.png" alt=""></p><p>现在从Font Squirrel下载下来的文件已经保存在你本地的电脑上了，接着只要对他进行解压缩，你就能看到文件列表如下所示：</p><p><img src="/images/posts/font-format.jpg" alt=""></p><p>大家可以看到，解压缩出来的文件格式，里面除了@font-face所需要的字体格式外，还带有一个DEMO文件，如果你不清楚的也可以参考下载下来的DEMO文件，我在这里不对DEMO说明问题，我主要是给大家介绍如何把下载下来的文件有价值的运用到我们的项目中。</p><p>例如在自己的本地创建了一个fontface项目：</p><p><img src="/images/posts/font-face-project.jpg" alt=""></p><p>为了让项目结构更清晰，我们在项目中单独创建一个fonts目录，用来放置解压缩出来@font-face所需的字体格式：</p><p><img src="/images/posts/font-face-project-demo.jpg" alt=""></p><p>现在@font-face所需字体已经加载到本地项目，现在本地项目中的style.css中附上我们需要的@font-face样式</p><pre><code class="css">@font-face {   font-family: &#39;SingleMaltaRegular&#39;;   src: url(&#39;../fonts/singlemalta-webfont.eot&#39;);   src: url(&#39;../fonts/singlemalta-webfont.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),        url(&#39;../fonts/singlemalta-webfont.woff&#39;) format(&#39;woff&#39;),    url(&#39;../fonts/singlemalta-webfont.ttf&#39;) format(&#39;truetype&#39;),    url(&#39;../fonts/singlemalta-webfont.svg#SingleMaltaRegular&#39;) format(&#39;svg&#39;);   font-weight: normal;   font-style: normal;}</code></pre><p>到这里为止，我们已经通过@font-face自定义好所需的SingleMalta字体，离最后效果只差一步了，就是把自己定义的字体应用到你的Web中的DOM元素上：</p><pre><code class="css">h2.singleMalta {  font-family: &#39;SingleMaltaRegular&#39;}</code></pre><p><strong>效果：</strong></p><p><img src="/images/posts/single-malta-font-demo.jpg" alt=""></p><p>看到上面的效果，那大家就知道我们实现成功了。那么关于@font-face帮你打造特殊效果的字体，到这里基本上就完成了，我在这里需要提醒使用者：</p><p>1、如果你的项目中是英文网站，而且项目中的Logo，Tags等应用到较多的这种特殊字体效果，我建议你不要使用图片效果，而使用@font-face，但是你是中文网站，我觉得还是使用图片比较合适，因为加载英文字体和图片没有多大区别，但是你加载中文字体，那就不一样了，因为中文字体太大了，这样会影响到项目的某些性能的优化；</p><p>2、致命的错误，你在@font-face中定义时，文件路径没有载对；</p><p>3、你只定义了@font-face，但并没有应用到你的项目中的DOM元素上；</p><p>以上几点都是在平时制作中常出现的问题，希望大家能小意一些，另外我们没有办法在购买所有字体，就算你实力雄厚，那也没有办法在一台服务器主机上放置你所有项目需要的字体。因此我给大家提供几个免费字体下载的网址：<a href="http://webfonts.fonts.com/" target="_blank" rel="noopener">Webfonts</a>,<a href="http://typekit.com/" target="_blank" rel="noopener">Typekit</a>,<a href="http://kernest.com/" target="_blank" rel="noopener">Kernest</a>,<a href="http://www.google.com/webfonts" target="_blank" rel="noopener">Google Web Fonts</a>,<a href="http://kernest.com/licenses" target="_blank" rel="noopener">Kernest</a>,<a href="http://www.dafont.com/" target="_blank" rel="noopener">Dafont</a>,<a href="http://nicewebtype.com/fonts/" target="_blank" rel="noopener">Niec Web Type</a>,不然你点<a href="http://www.google.com/search?q=webfonts" target="_blank" rel="noopener">这里</a>将有更多的免费字体。前面几个链接是帮助你获取一些优美的怪异的特殊字体，但下面这个工具作用更是无穷的大，他能帮你生成@font-face所需要的各种字体，这工具就是<a href="http://www.fontsquirrel.com/fontface/generator" target="_blank" rel="noopener">Font Squirrel</a>。</p><p><strong>最后在提醒一下，使用@font-face别的可以忘了，但<a href="http://www.fontsquirrel.com/fontface/generator" target="_blank" rel="noopener">Font Squirrel</a>千万不能忘，因为他能帮你生成@font-face所需的各种字体格式。</strong></p><p>到此关于@font-face就介绍完了，不知道大家喜欢不喜欢，如果喜欢的话赶快动手实践一下，有Blog的可以马上运用上去，也可以炫一下。</p><p><strong>2014年03月更新—</strong>—@font-face无法在Firefox下正常工作的解决方案，详细的请点击：<a href="http://stackoverflow.com/questions/2856502/css-font-face-not-working-with-firefox-but-working-with-chrome-and-ie" target="_blank" rel="noopener">http://stackoverflow.com/questions/2856502/css-font-face-not-working-with-firefox-but-working-with-chrome-and-ie</a></p><p>本文转自<a href="http://www.w3cplus.com/" target="_blank" rel="noopener">W3CPLUS</a> 的《<a href="http://www.w3cplus.com/content/css3-font-face" target="_blank" rel="noopener">CSS @font-face</a>》<br>如需转载烦请注明出处：<a href="http://www.w3cplus.com/" target="_blank" rel="noopener">W3CPLUS</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 字体 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python实现加密方法合集</title>
      <link href="/posts/2020-01-08-6575.html"/>
      <url>/posts/2020-01-08-6575.html</url>
      
        <content type="html"><![CDATA[<p>我们所说的加密方式，都是对二进制编码的格式进行加密的，对应到Python中，则是我们的Bytes。所以当我们在Python中进行加密操作的时候，要确保我们操作的是Bytes，否则就会报错。</p><a id="more"></a><p><img src="/images/posts/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.jpg" alt="对称加密算法"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>明文：明文是指没有经过加密的数据。一般而言，明文都是等待传输的数据。由于没有经过加密，明文很容易被识别与破解，因此在传输明文之前必须进行加密处理。</li><li>密文：密文只是明文经过某种加密算法而得到的数据，通常密文的形式复杂难以识别及理解。</li><li>密钥：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。</li><li>对称加密：通信双方同时掌握一个密钥，加密解密都是由一个密钥完成的（即加密密钥等于解密密钥，加解密密钥可以相互推倒出来）。双方通信前共同拟定一个密钥，不对第三方公开。</li><li>分组加密：分组密码是将明文分成固定长度的组，每一组都采用同一密钥和算法进行加密，输出也是固定长度的密文。</li></ul><h2 id="加密算法分类"><a href="#加密算法分类" class="headerlink" title="加密算法分类"></a>加密算法分类</h2><h3 id="对称加密算法："><a href="#对称加密算法：" class="headerlink" title="对称加密算法："></a>对称加密算法：</h3><p>对称加密采用了对称密码编码技术，它的特点是文件加密和解密使用相同的密钥</p><p>发送方和接收方需要持有同一把密钥，发送消息和接收消息均使用该密钥。</p><p>相对于非对称加密，对称加密具有更高的加解密速度，但双方都需要事先知道密钥，密钥在传输过程中可能会被窃取，因此安全性没有非对称加密高。</p><p>常见的对称加密算法：DES，AES，3DES等等</p><h3 id="非对称加密算法："><a href="#非对称加密算法：" class="headerlink" title="非对称加密算法："></a>非对称加密算法：</h3><p>文件加密需要公开密钥（publickey）和私有密钥（privatekey）。</p><p>接收方在发送消息前需要事先生成公钥和私钥，然后将公钥发送给发送方。发送放收到公钥后，将待发送数据用公钥加密，发送给接收方。接收到收到数据后，用私钥解密。</p><p>在这个过程中，公钥负责加密，私钥负责解密，数据在传输过程中即使被截获，攻击者由于没有私钥，因此也无法破解。</p><p>非对称加密算法的加解密速度低于对称加密算法，但是安全性更高。</p><p>非对称加密算法：RSA、DSA、ECC等算法</p><h3 id="消息摘要算法："><a href="#消息摘要算法：" class="headerlink" title="消息摘要算法："></a>消息摘要算法：</h3><p>消息摘要算法可以验证信息是否被篡改。</p><p>在数据发送前，首先使用消息摘要算法生成该数据的签名，然后签名和数据一同发送给接收者。</p><p>接收者收到数据后，对收到的数据采用消息摘要算法获得签名，最后比较签名是否一致，以此来判断数据在传输过程中是否发生修改。</p><h2 id="Python实现加密方法合集"><a href="#Python实现加密方法合集" class="headerlink" title="Python实现加密方法合集"></a>Python实现加密方法合集</h2><pre><code class="python"># -*- coding：utf-8 -*-import base64import rsafrom Crypto.Cipher import AESfrom Crypto.PublicKey import RSAfrom pyDes import des, CBC, PAD_PKCS5from Crypto.Cipher import DES3import hashlibimport hmacclass USE_AES:    &quot;&quot;&quot;    AES    除了MODE_SIV模式key长度为：32, 48, or 64,    其余key长度为16, 24 or 32    详细见AES内部文档    CBC模式传入iv参数    本例使用常用的ECB模式    &quot;&quot;&quot;    def __init__(self, key):        if len(key) &gt; 32:            key = key[:32]        self.key = self.to_16(key)    def to_16(self, key):        &quot;&quot;&quot;        转为16倍数的bytes数据        :param key:        :return:        &quot;&quot;&quot;        key = bytes(key, encoding=&quot;utf8&quot;)        while len(key) % 16 != 0:            key += b&#39;\0&#39;        return key  # 返回bytes    def aes(self):        return AES.new(self.key, AES.MODE_ECB) # 初始化加密器    def encrypt(self, text):        aes = self.aes()        return str(base64.encodebytes(aes.encrypt(self.to_16(text))),                   encoding=&#39;utf8&#39;).replace(&#39;\n&#39;, &#39;&#39;)  # 加密    def decodebytes(self, text):        aes = self.aes()        return str(aes.decrypt(base64.decodebytes(bytes(            text, encoding=&#39;utf8&#39;))).rstrip(b&#39;\0&#39;).decode(&quot;utf8&quot;))  # 解密class USE_RSA:    &quot;&quot;&quot;    生成密钥可保存.pem格式文件    1024位的证书，加密时最大支持117个字节，解密时为128；    2048位的证书，加密时最大支持245个字节，解密时为256。    加密大文件时需要先用AES或者DES加密，再用RSA加密密钥，详细见文档    文档:https://stuvel.eu/files/python-rsa-doc/usage.html#generating-keys    &quot;&quot;&quot;    def __init__(self, number=1024):        &quot;&quot;&quot;        :param number: 公钥、私钥        &quot;&quot;&quot;        self.pubkey, self.privkey = rsa.newkeys(number)    def rsaEncrypt(self, text):        &quot;&quot;&quot;        :param test: str        :return: bytes        &quot;&quot;&quot;        content = text.encode(&#39;utf-8&#39;)        crypto = rsa.encrypt(content, self.pubkey)        return crypto    def rsaDecrypt(self, text):        &quot;&quot;&quot;        :param text:bytes         :return: str        &quot;&quot;&quot;        content = rsa.decrypt(text, self.privkey)        con = content.decode(&#39;utf-8&#39;)        return con    def savePem(self, path_name, text):        &quot;&quot;&quot;        :param path_name: 保存路径        :param text: str        :return:bytes        &quot;&quot;&quot;        if &quot;PEM&quot; in path_name.upper():            path_name = path_name[:-4]        with open(&#39;{}.pem&#39;.format(path_name), &#39;bw&#39;) as f:            f.write(text.save_pkcs1())    def readPem(self, path_name, key_type):        &quot;&quot;&quot;        :param path_name: 密钥文件        :param key_type:类型         :return:         &quot;&quot;&quot;        if &#39;pubkey&#39; in key_type:            self.pubkey = rsa.PublicKey.load_pkcs1(path_name)        else:            self.privkey = rsa.PublicKey.load_pkcs1(path_name)        return True    def sign(self, message, priv_key=None, hash_method=&#39;SHA-1&#39;):        &quot;&quot;&quot;        生成明文的哈希签名以便还原后对照        :param message: str        :param priv_key:        :param hash_method: 哈希的模式        :return:        &quot;&quot;&quot;        if None == priv_key:            priv_key = self.privkey        return rsa.sign(message.encode(), priv_key, hash_method)    def checkSign(self, mess, result, pubkey=None):        &quot;&quot;&quot;        验证签名：传入解密后明文、签名、公钥，验证成功返回哈希方法，失败则报错        :param mess: str        :param result: bytes        :param pubkey:         :return: str        &quot;&quot;&quot;        if None == pubkey:            pubkey = self.privkey        try:            result = rsa.verify(mess, result, pubkey)            return result        except:            return Falseclass USE_DES:    &quot;&quot;&quot;    des(key,[mode], [IV], [pad], [pad mode])    key:必须正好8字节    mode（模式）：ECB、CBC    iv:CBC模式中必须提供长8字节    pad:填充字符    padmode:加密填充模式PAD_NORMAL or PAD_PKCS5    &quot;&quot;&quot;    def __init__(self, key, iv):        if not isinstance(key, bytes):            key = bytes(key, encoding=&quot;utf8&quot;)        if not isinstance(iv, bytes):            iv = bytes(iv, encoding=&quot;utf8&quot;)        self.key = key        self.iv = iv    def encrypt(self, text):        &quot;&quot;&quot;        DES 加密        :param text: 原始字符串        :return: 加密后字符串，bytes        &quot;&quot;&quot;        if not isinstance(text, bytes):            text = bytes(text, &quot;utf-8&quot;)        secret_key = self.key        iv = self.iv        k = des(secret_key, CBC, iv, pad=None, padmode=PAD_PKCS5)        en = k.encrypt(text, padmode=PAD_PKCS5)        return en    def descrypt(self, text):        &quot;&quot;&quot;        DES 解密        :param text: 加密后的字符串，bytes        :return:  解密后的字符串        &quot;&quot;&quot;        secret_key = self.key        iv = self.iv        k = des(secret_key, CBC, iv, pad=None, padmode=PAD_PKCS5)        de = k.decrypt(text, padmode=PAD_PKCS5)        return de.decode()class USE_DES3:    &quot;&quot;&quot;    new(key, mode, *args, **kwargs)    key:必须8bytes倍数介于16-24    mode：    iv:初始化向量适用于MODE_CBC、MODE_CFB、MODE_OFB、MODE_OPENPGP，4种模式        ``MODE_CBC``, ``MODE_CFB``, and ``MODE_OFB``长度为8bytes        ```MODE_OPENPGP```加密时8bytes解密时10bytes        未提供默认随机生成    nonce：仅在 ``MODE_EAX`` and ``MODE_CTR``模式中使用            ``MODE_EAX``建议16bytes            ``MODE_CTR``建议[0, 7]长度            未提供则随机生成    segment_size：分段大小，仅在 ``MODE_CFB``模式中使用，长度为8倍数，未指定则默认为8    mac_len： 适用``MODE_EAX``模式，身份验证标记的长度（字节），它不能超过8（默认值）    initial_value：适用```MODE_CTR```，计数器的初始值计数器块。默认为**0**。    &quot;&quot;&quot;    def __init__(self, key):        self.key = key        self.mode = DES3.MODE_ECB    def encrypt(self, text):        &quot;&quot;&quot;        传入明文        :param text:bytes类型，长度是KEY的倍数        :return:        &quot;&quot;&quot;        if not isinstance(text, bytes):            text = bytes(text, &#39;utf-8&#39;)        x = len(text) % 8        text = text+b&#39;\0&#39;*x        cryptor = DES3.new(self.key, self.mode)        ciphertext = cryptor.encrypt(text)        return ciphertext    def decrypt(self, text):        cryptor = DES3.new(self.key, self.mode)        plain_text = cryptor.decrypt(text)        st = str(plain_text.decode(&quot;utf-8&quot;)).rstrip(&#39;\0&#39;)        return stdef USE_MD5(test):    if not isinstance(test, bytes):        test = bytes(test, &#39;utf-8&#39;)    m = hashlib.md5()    m.update(test)    return m.hexdigest()def USE_HMAC(key, text):    if not isinstance(key, bytes):        key = bytes(key, &#39;utf-8&#39;)    if not isinstance(text, bytes):        text = bytes(text, &#39;utf-8&#39;)    h = hmac.new(key, text, digestmod=&#39;MD5&#39;)    return h.hexdigest()def USE_SHA(text):    if not isinstance(text, bytes):        text = bytes(text, &#39;utf-8&#39;)    sha = hashlib.sha1(text)    encrypts = sha.hexdigest()    return encryptsif __name__ == &#39;__main__&#39;:    aes_test = USE_AES(&quot;assssssssdfasasasasa&quot;)    a = aes_test.encrypt(&quot;测试&quot;)    b = aes_test.decodebytes(a)    rsa_test = USE_RSA()    a = rsa_test.rsaEncrypt(&quot;测试加密&quot;)    b = rsa_test.rsaDecrypt(a)    des_test = USE_DES(b&quot;12345678&quot;, b&quot;12345678&quot;)    a = des_test.encrypt(&quot;测试加密&quot;)    b = des_test.descrypt(a)    des3_test = USE_DES3(b&quot;123456789qazxswe&quot;)    a = des3_test.encrypt(&quot;测试加密&quot;)    b = des3_test.decrypt(a)    md5_test = USE_MD5(&quot;测试签名&quot;)    hmac_test = USE_HMAC(&quot;123456&quot;, &quot;测试&quot;)    sha_test = USE_SHA(&quot;测试加密&quot;)</code></pre><p>Github: <a href="https://github.com/dhfjcuff/R-A-M-D-D3-S-M-H/blob/master/RSA-AES-MD5-DES-DES3-MD5-SHA-HMAC.py" target="_blank" rel="noopener">https://github.com/dhfjcuff/R-A-M-D-D3-S-M-H/blob/master/RSA-AES-MD5-DES-DES3-MD5-SHA-HMAC.py</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 加密 </tag>
            
            <tag> 解密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写python脚本遍历文件夹并取指定后缀名文件</title>
      <link href="/posts/2019-12-29-25741.html"/>
      <url>/posts/2019-12-29-25741.html</url>
      
        <content type="html"><![CDATA[<p>用python来遍历某个文件并获取指定后缀名文件</p><a id="more"></a><h2 id="python-实现函数代码"><a href="#python-实现函数代码" class="headerlink" title="python 实现函数代码"></a>python 实现函数代码</h2><pre><code>suffix = &#39;.php&#39;def get_file_list(_dir):    i = 0    for root, dirs, files in os.walk(_dir):        for f in files:            f_path = os.path.join(root, f)            if f_path.endswith(suffix):                f_path2 = &#39;/&#39; + f_path.replace(_dir, &#39;&#39;).strip(&#39;/&#39;)                print f_path2</code></pre><h2 id="walk-函数"><a href="#walk-函数" class="headerlink" title="walk 函数"></a>walk 函数</h2><pre><code>os.walk() 方法是一个简单易用的文件、目录遍历器，可以帮助我们高效的处理文件、目录方面的事情。用于通过在目录树中游走输出在目录中的文件名，向上或者向下。</code></pre><h3 id="walk-语法"><a href="#walk-语法" class="headerlink" title="walk 语法"></a>walk 语法</h3><pre><code>os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])</code></pre><h3 id="walk-参数"><a href="#walk-参数" class="headerlink" title="walk 参数"></a>walk 参数</h3><ul><li>top – 是你所要遍历的目录的地址, 返回的是一个三元组(root,dirs,files)。<ul><li>root 所指的是当前正在遍历的这个文件夹的本身的地址</li><li>dirs 是一个 list ，内容是该文件夹中所有的目录的名字(不包括子目录)</li><li>files 同样是 list , 内容是该文件夹中所有的文件(不包括子目录)</li></ul></li><li>topdown –可选，为 True，则优先遍历 top 目录，否则优先遍历 top 的子目录(默认为开启)。如果 topdown 参数为 True，walk 会遍历top文件夹，与top 文件夹中每一个子目录。</li><li>onerror – 可选，需要一个 callable 对象，当 walk 需要异常时，会调用。</li><li>followlinks – 可选，如果为 True，则会遍历目录下的快捷方式(linux 下是软连接 symbolic link )实际所指的目录(默认关闭)，如果为 False，则优先遍历 top 的子目录。</li></ul><h3 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h3><ul><li>root: 返回给定根目录，但是在有下级文件夹时候会改变</li><li>dir:如果有个文件夹下面存在文件，就是返回为空，这个时候root不为空，我们可以这种方法来处理数据。</li><li>flies:如果不为空，就为底层文件。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 文件夹 </tag>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用国内pip 源</title>
      <link href="/posts/2019-12-28-9867.html"/>
      <url>/posts/2019-12-28-9867.html</url>
      
        <content type="html"><![CDATA[<p>有些服务器对外网络很坑，幸好国内有好多优秀的源镜像</p><a id="more"></a><p>优秀pip源推荐</p><pre><code>http://pypi.douban.com/  豆瓣http://pypi.hustunique.com/  华中理工大学http://pypi.sdutlinux.org/  山东理工大学http://pypi.mirrors.ustc.edu.cn/  中国科学技术大学</code></pre><pre><code>pip install web.py -i https://pypi.douban.com/simple</code></pre><p>~/.pip/pip.conf</p><pre><code>[global]index-url = https://pypi.douban.com/simple</code></pre><h2 id="清华大学开源镜像"><a href="#清华大学开源镜像" class="headerlink" title="清华大学开源镜像"></a>清华大学开源镜像</h2><p><a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/</a></p><p>临时使用</p><pre><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</code></pre><p>注意，<code>simple</code> 不能少, 是 <code>https</code> 而不是 <code>http</code></p><p>设为默认 升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置：</p><pre><code>pip install pip -Upip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pip </tag>
            
            <tag> 国内源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 用base64 对图片文件的编码和解码处理</title>
      <link href="/posts/2019-12-28-35102.html"/>
      <url>/posts/2019-12-28-35102.html</url>
      
        <content type="html"><![CDATA[<p>用base64 对图片文件的编码和解码处理</p><a id="more"></a><pre><code>import base64def convert(image):    f = open(image)    img_raw_data = f.read()    f.close()    img_b64_string = base64.b64encode(img_raw_data)    convert_img_raw_data = base64.b64decode(img_b64_string)    t = open(&quot;example.png&quot;, &quot;w+&quot;)    t.write(convert_img_raw_data)    t.close()if __name__ == &quot;__main__&quot;:    convert(&quot;test.png&quot;)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> base64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 根据字符串随机生成颜色</title>
      <link href="/posts/2019-12-28-38278.html"/>
      <url>/posts/2019-12-28-38278.html</url>
      
        <content type="html"><![CDATA[<p>遇到这么一个需求：根据用户名或用户id，随机生成一个颜色。其实就是用python 根据字符串随机生成颜色。</p><a id="more"></a><h2 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h2><p>下面是python 实现。</p><pre><code class="python">import hashlibdef hsv2rgb(h, s, v):    h += 0.618033988749895    h %= 1    h_i = int(h*6)    f = h*6 - h_i    p = v * (1 - s)    q = v * (1 - f*s)    t = v * (1 - (1 - f) * s)    if h_i == 0:        r, g, b = v, t, p    elif h_i == 1:        r, g, b = q, v, p    elif h_i == 2:        r, g, b = p, v, t    elif h_i == 3:        r, g, b = p, q, v    elif h_i == 4:        r, g, b = t, p, v    elif h_i == 5:        r, g, b = v, p, q    else:        r = g = b = 0    return [int(r*256), int(g*256), int(b*256)]def str2rgb(obj):    digest = hashlib.sha384(str(obj).encode(&#39;utf-8&#39;)).hexdigest()    sub_size = int(len(digest) / 3)    max_value = float(int(&quot;f&quot; * sub_size, 16))    digests = [digest[i * sub_size: (i + 1) * sub_size] for i in range(3)]    rgb = (((int(d, 16) / max_value)+0.618033988749895) % 1 for d in digests)    return &#39;#&#39; + &#39;&#39;.join([&quot;%02x&quot; % int(c*255 + 0.5 - 0.0000005) for c in rgb])def str2rgb2(obj):    digest = hashlib.sha384(str(obj).encode(&#39;utf-8&#39;)).hexdigest()    obj_value = int(digest, 16)    max_value = float(int(&quot;f&quot; * len(digest), 16))    rgb = hsv2rgb(obj_value/max_value, 0.5, 0.95)    return &#39;#&#39; + &#39;&#39;.join([&quot;%02x&quot; % c for c in rgb])</code></pre><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>上面有两种实现，其效果如下：<br><img src="/images/posts/str2rgb.png" alt="str2rgb.png"><br><img src="/images/posts/str2rgb2.png" alt="str2rgb2.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>第一种颜色较深，只要传入字符串不同，其颜色就不同。</li><li>第二种颜色较淡，过渡自然，但第二种只有732 种颜色。</li></ul><p>如果为了不同的颜色就使用第一种，如果允许相同的颜色，又要求柔和、自然接近，就考虑第二种。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 随机 </tag>
            
            <tag> 颜色 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python获取当前运行文件路径的方法</title>
      <link href="/posts/2019-12-28-18016.html"/>
      <url>/posts/2019-12-28-18016.html</url>
      
        <content type="html"><![CDATA[<p>下面是python获取当前运行文件路径的方法</p><a id="more"></a><h2 id="通过-file-获取"><a href="#通过-file-获取" class="headerlink" title="通过 file 获取"></a>通过 <strong>file</strong> 获取</h2><pre><code>os.path.dirname(os.path.realpath(__file__))</code></pre><h2 id="通过-getcwd-获取当前路径"><a href="#通过-getcwd-获取当前路径" class="headerlink" title="通过 getcwd 获取当前路径"></a>通过 getcwd 获取当前路径</h2><pre><code>os.getcwd()</code></pre><p>更详细的 path 文档 <a href="https://docs.python.org/2/library/os.path.html" target="_blank" rel="noopener">https://docs.python.org/2/library/os.path.html</a></p><h2 id="其它相关路径"><a href="#其它相关路径" class="headerlink" title="其它相关路径"></a>其它相关路径</h2><pre><code>#当前文件路径print(os.path.realpath(__file__))#当前文件所在的目录，即父路径print(os.path.split(os.path.realpath(__file__))[0])#找到父路径下的其他文件，即同级的其他文件print(os.path.join(proDir,&quot;config.ini&quot;))</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 文件路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python PIL 生成图片验证码</title>
      <link href="/posts/2019-12-28-63494.html"/>
      <url>/posts/2019-12-28-63494.html</url>
      
        <content type="html"><![CDATA[<p>下面是一个用python PIL 生成验证码的函数。</p><a id="more"></a><p>过程是：创建一张有底色的图片、在背景上添加杂色、写上特定文字、保存图片</p><pre><code># -*- coding: utf-8 -*-import randomimport Imageimport ImageFontimport ImageDrawimport ImageFilterdef gen_captcha(text, fnt, fnt_sz, file_name, fmt=&#39;JPEG&#39;):    # 随机生成背景色    fgcolor = random.randint(0,0xffff00)    bgcolor = fgcolor ^ 0xffffff    # 生成文字    font = ImageFont.truetype(fnt,fnt_sz)    dim = font.getsize(text)    im = Image.new(&#39;RGB&#39;, (dim[0]+5,dim[1]+5), bgcolor)    d = ImageDraw.Draw(im)    x, y = im.size    r = random.randint    # 给背景添加杂色    for num in range(100):        d.rectangle((r(0,x), r(0,y), r(0,x), r(0,y)), fill=r(0, 0xffffff))    # 添加文字    d.text((3,3), text, font=font, fill=fgcolor)    im = im.filter(ImageFilter.EDGE_ENHANCE_MORE)    im.save(file_name, format=fmt)def gen_random_word(wordLen=6):    allowedChars = &quot;abcdefghijklmnopqrstuvwzyzABCDEFGHIJKLMNOPQRSTUVWZYZ0123456789&quot;    word = &quot;&quot;    for i in range(0, wordLen):        word = word + allowedChars[random.randint(0,0xffffff) % len(allowedChars)]    return wordif __name__ == &#39;__main__&#39;:    word = gen_random_word()    print word    gen_captcha(word.strip(), &#39;porkys.ttf&#39;, 65, &quot;test.jpg&quot;)</code></pre><h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><p>一般情况不会要求填写验证码，避免影响用户体验。在特定情况下，如当用户登录密码出错N 次后，当用户频繁发贴时。</p><p>可对验证码作更复杂的变换，当用户输入验证码出错次数为N 时，增加其难度，如增加字符集、变化字体等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> PIL </tag>
            
            <tag> 验证码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用python 正确计算大文件md5 值</title>
      <link href="/posts/2019-12-28-4278.html"/>
      <url>/posts/2019-12-28-4278.html</url>
      
        <content type="html"><![CDATA[<p>python 计算文件的md5值很方便，但如果只是简单的把文件都入到内存中，大文件会导致问题，一般采用切片的方式分段计算，下面的几个函数可以很好的解决这个问题。</p><a id="more"></a><h2 id="使用-hashlib"><a href="#使用-hashlib" class="headerlink" title="使用 hashlib"></a>使用 hashlib</h2><pre><code>import hashlibdef md5_for_file(f, block_size=2**20):    md5 = hashlib.md5()    while True:        data = f.read(block_size)        if not data:            break        md5.update(data)    return md5.digest()def md5sum(filename, blocksize=65536):    hash = hashlib.md5()    with open(filename, &quot;r+b&quot;) as f:        for block in iter(lambda: f.read(blocksize), &quot;&quot;):            hash.update(block)    return hash.hexdigest()</code></pre><h2 id="使用-Crypto-Hash"><a href="#使用-Crypto-Hash" class="headerlink" title="使用 Crypto.Hash"></a>使用 Crypto.Hash</h2><pre><code>import osfrom Crypto.Hash import MD5def get_file_checksum(filename):    h = MD5.new()    chunk_size = 8192    with open(filename, &#39;rb&#39;) as f:        while True:            chunk = f.read(chunk_size)            if len(chunk) == 0:                break            h.update(chunk)    return h.hexdigest()</code></pre><p>上面三个函数都能正确计算大文件md5 值</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> md5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/2019-12-24-16107.html"/>
      <url>/posts/2019-12-24-16107.html</url>
      
        <content type="html"><![CDATA[<p>基于Hexo编写的轻巧简洁小清新博客。</p><a id="more"></a><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> install </tag>
            
            <tag> nodeJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python form-data post上传数据简便方法</title>
      <link href="/posts/2019-12-24-54485.html"/>
      <url>/posts/2019-12-24-54485.html</url>
      
        <content type="html"><![CDATA[<p>有时要用到 form-data 这种形式post 上传文件到服务器，下面介绍使用python 实现的简便方法。</p><a id="more"></a><p><img src="/images/posts/python-formdata-post.jpg" alt="python-formdata-post"></p><h2 id="方法一，使用-urllib2-自己打包"><a href="#方法一，使用-urllib2-自己打包" class="headerlink" title="方法一，使用 urllib2 自己打包"></a>方法一，使用 urllib2 自己打包</h2><p>自己封装form-data 也很方便</p><pre><code>def test():    #boundary只要是随机不同的就行    boundary = &#39;----------%s&#39; % hex(int(time.time() * 1000))    data = []    data.append(&#39;--%s&#39; % boundary)    fr=open(r&#39;test2.jpg&#39;,&#39;rb&#39;)    data.append(&#39;Content-Disposition: form-data; name=&quot;%s&quot;; filename=&quot;new_test2.jpg&quot;&#39; % &#39;file&#39;)    data.append(&#39;Content-Type: %s\r\n&#39; % &#39;image/jpeg&#39;)    data.append(fr.read())    fr.close()    data.append(&#39;--%s--\r\n&#39; % boundary)    #http_url=&#39;http://remotserver.com/page.php&#39;    http_url = &#39;http://xxx/v1/upload&#39;    http_body=&#39;\r\n&#39;.join(data)    try:        #buld http request        req=urllib2.Request(http_url, data=http_body)        #header        req.add_header(&#39;Content-Type&#39;, &#39;multipart/form-data; boundary=%s&#39; % boundary)#最重要的一行        #post data to server        resp = urllib2.urlopen(req, timeout=5)        #get response        qrcont=resp.read()        print qrcont    except Exception,e:        print &#39;http error&#39;</code></pre><h2 id="方法二，使用request"><a href="#方法二，使用request" class="headerlink" title="方法二，使用request"></a>方法二，使用request</h2><p>更简洁</p><pre><code>import requestsurl = &#39;xxx&#39;files={&#39;file&#39;:(&#39;newname.jpg&#39;,open(&#39;localname.jpg&#39;,&#39;rb&#39;),&#39;image/jpeg&#39;)}rsp=requests.post(url,files=files)print(rsp.request.text)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> form </tag>
            
            <tag> data </tag>
            
            <tag> post </tag>
            
            <tag> 上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用SSH 密钥登录VPS</title>
      <link href="/posts/2019-12-24-16726.html"/>
      <url>/posts/2019-12-24-16726.html</url>
      
        <content type="html"><![CDATA[<p>以前没有在VPS 上部署重要的东西，设置一个稍复杂的密码就可以。下面对记录一下VPS 禁止用户名+密码登录，仅使用密钥登录的过程。</p><a id="more"></a><p><img src="/images/posts/SSH%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95VPS.jpg" alt="SSH密钥登录VPS"></p><h2 id="生成SSH-公钥"><a href="#生成SSH-公钥" class="headerlink" title="生成SSH 公钥"></a>生成SSH 公钥</h2><p>确认是否已经有一个公钥，即检查<code>.ssh</code>文件夹，以及文件夹中是否存在<code>id_rsa</code> 和 <code>id_rsa.pub</code>文件，有.pub后缀的文件就是公钥，另一个文件则是密钥。如果不存在，或者干脆连<code>.ssh</code>文件夹都没有，可以进行创建。如果存在，就直接把<code>id_rsa.pub</code>内容输出，粘贴的服务器的相关文件。</p><pre><code>$ cd ~/.ssh$ ls</code></pre><p>可以用<code>ssh-keygen</code>来创建<br>默认公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空。</p><h2 id="更改VPS-sshd-配置"><a href="#更改VPS-sshd-配置" class="headerlink" title="更改VPS sshd 配置"></a>更改VPS sshd 配置</h2><p>编辑sshd 配置文件 <code>/etc/ssh/sshd_config</code><br>找到并修改为下面的样子：</p><pre><code>RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile      %h/.ssh/authorized_keysPasswordAuthentication no</code></pre><h3 id="添加公钥"><a href="#添加公钥" class="headerlink" title="添加公钥"></a>添加公钥</h3><p>打开文件<code>~/.ssh/authorized_keys</code>， 把本地的<code>id_rsa.pub</code> 内容粘贴到里面，保存退出</p><h3 id="重启sshd-服务"><a href="#重启sshd-服务" class="headerlink" title="重启sshd 服务"></a>重启sshd 服务</h3><pre><code>service sshd restart</code></pre><h2 id="其它安全措施"><a href="#其它安全措施" class="headerlink" title="其它安全措施"></a>其它安全措施</h2><p>上面所说的登录方式只是最基本的安全措施，还有比如更改ssh 默认端口、禁止root用户登录、使用denyhosts、启用iptables限制等等。</p><p>查看尝试暴力破解机器密码的人</p><pre><code>grep &quot;Failed password for root&quot; /var/log/auth.log | awk &#39;{print $11}&#39; | sort | uniq -c | sort -nr | more</code></pre><h2 id="查看成功登录信息"><a href="#查看成功登录信息" class="headerlink" title="查看成功登录信息"></a>查看成功登录信息</h2><pre><code>查看当前登录用户信息who命令：who缺省输出包括用户名、终端类型、登陆日期以及远程主机。who /var/log/wtmplastlast 用户名last -t 20181206160404显示这个时间戳之前的登陆历史</code></pre><h2 id="客户端密钥备份"><a href="#客户端密钥备份" class="headerlink" title="客户端密钥备份"></a>客户端密钥备份</h2><p>如果电脑重装了，就很难登录服务器，可以备份密钥，直接复制<code>id_rsa</code>、<code>id_rsa.pub</code>两个文件。当电脑重装或者想在其他电脑上登录主机，直接把这两个文件复制到 <code>~/.ssh/</code> 目录下就行。<br>如果使用备份的<code>id_rsa</code> 文件出现下面的错误提示</p><pre><code>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0644 for &#39;id_rsa&#39; are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored.</code></pre><p>可以用更改文件属性的方法来解决</p><pre><code>chmod 0600 id_rsa</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> VPS </tag>
            
            <tag> SSH </tag>
            
            <tag> 密钥 </tag>
            
            <tag> 登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenSSL 生成自签名证书备忘</title>
      <link href="/posts/2019-12-24-63828.html"/>
      <url>/posts/2019-12-24-63828.html</url>
      
        <content type="html"><![CDATA[<p>用 OpenSSL 生成自签名证书的步骤：</p><a id="more"></a><p><img src="/images/posts/OpenSSL.jpg" alt="OpenSSL"></p><ul><li>创建Key； </li><li>创建签名请求；</li><li>将Key的口令移除；</li><li>用Key签名证书。<br>为HTTPS准备的证书需要注意，创建的签名请求的CN必须与域名完全一致，否则无法通过浏览器验证。<br>具体命令如下，把域名改为自己的域名：<pre><code>openssl genrsa -des3 -out $DOMAIN.key 1024openssl req -new -subj &quot;/C=US/ST=Mars/L=iTranswarp/O=iTranswarp/OU=iTranswarp/CN=$DOMAIN&quot; -key $DOMAIN.key -out $DOMAIN.csrmv $DOMAIN.key $DOMAIN.origin.keyopenssl rsa -in $DOMAIN.origin.key -out $DOMAIN.keyopenssl x509 -req -days 3650 -in $DOMAIN.csr -signkey $DOMAIN.key -out $DOMAIN.crt</code></pre>有时需要下面两个文件名更加方便识别：<pre><code>cp $DOMAIN.crt cert.pemcp $DOMAIN.key key.pem</code></pre>nginx 配置：<pre><code>ssl_certificate     $DOMAIN.crt;ssl_certificate_key $DOMAIN.key;</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> OpenSSL </tag>
            
            <tag> 证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac pip2 与 pip3 共存</title>
      <link href="/posts/2019-12-24-6349.html"/>
      <url>/posts/2019-12-24-6349.html</url>
      
        <content type="html"><![CDATA[<p>Mac 上的 pip2 与 pip3 共存笔记</p><a id="more"></a><p><img src="/images/posts/pip2-pip3.jpg" alt="pip2-pip3"><br>这里不想启用<code>pyenv</code><br>下载 <code>get-pip.py</code></p><pre><code>curl -O https://bootstrap.pypa.io/get-pip.py</code></pre><p>首先安装pip （pip2）</p><pre><code>sudo python2 get-pip.py</code></pre><p>再安装 <code>pip3</code></p><pre><code>sudo python3 get-pip.py</code></pre><p>测试：</p><pre><code>$ pip -Vpip 18.1 from /Library/Python/2.7/site-packages/pip-18.1-py2.7.egg/pip (python 2.7)$ pip2 -Vpip 18.1 from /Library/Python/2.7/site-packages/pip-18.1-py2.7.egg/pip (python 2.7)$ pip3 -Vpip 18.1 from /usr/local/lib/python3.6/site-packages/pip (python 3.6)</code></pre><p>如果失败就动用 <code>easy_install</code> 来安装：</p><pre><code>sudo easy_install pip</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> pip2 </tag>
            
            <tag> pip3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenWrt 国内源</title>
      <link href="/posts/2019-12-24-11985.html"/>
      <url>/posts/2019-12-24-11985.html</url>
      
        <content type="html"><![CDATA[<p>国内可用 OpenWrt 镜像</p><a id="more"></a><ul><li><a href="https://mirrors.ustc.edu.cn/lede/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/lede/</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/openwrt/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/openwrt/</a> 只更新到 chaos_calmer/15.05.1/</li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/lede/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/lede/</a> openwrt 最新版</li></ul><p>官方网站推荐的其他镜像</p><ul><li><a href="https://openwrt.org/downloads#mirrors" target="_blank" rel="noopener">https://openwrt.org/downloads#mirrors</a></li></ul><p>修改文件 <code>/etc/opkg/distfeeds.conf</code><br><img src="/images/posts/OpenWrt.png" alt="OpenWrt"></p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenWrt </tag>
            
            <tag> 国内 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开启BBR 加速小VPS访问速度</title>
      <link href="/posts/2019-12-24-27787.html"/>
      <url>/posts/2019-12-24-27787.html</url>
      
        <content type="html"><![CDATA[<p>TCP BBR 是 Google 开发的新的拥塞控制算法，据说是用在 YouTube 上，后来开源并且已经集成到 Linux 4.9-rc8 之后版本的内核中。它可以极大提高网络速度，大大降低延迟。</p><a id="more"></a><p>加速效果如下图所示：<br><img src="/images/posts/open-BBR.gif" alt="open-BBR"><br>如果你的 VPS 使用的是 OpenVZ 的虚拟技术，你是不能使用 BBR 的。并且系统要求在 CentOS 6+，Debian 7+，Ubuntu 12+。<br>对于4.9+的内核，默认编译了 TCP BBR 的内容，可以直接通过参数开启<br>uname -r 看看是不是内核 &gt;= 4.9<br>执行 <code>lsmod | grep bbr</code> ，如果结果中没有 <code>tcp_bbr</code> 的话就先执行</p><pre><code>modprobe tcp_bbrecho &quot;tcp_bbr&quot; &gt;&gt; /etc/modules-load.d/modules.conf</code></pre><p>执行</p><pre><code>echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.confecho &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</code></pre><p>保存生效</p><pre><code>sysctl -p</code></pre><p>执行</p><pre><code>sysctl net.ipv4.tcp_available_congestion_controlsysctl net.ipv4.tcp_congestion_control</code></pre><p>如果结果都有bbr, 则证明你的内核已开启bbr</p><p>看到有 tcp_bbr 模块即说明bbr已启动</p><p>再实行 <code>lsmod | grep bbr</code>，显示以下即启动成功：</p><pre><code>lsmod | grep bbrtcp_bbr                20480  14</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> BBR </tag>
            
            <tag> 开启 </tag>
            
            <tag> 访问速度 </tag>
            
            <tag> VPS </tag>
            
            <tag> 加速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Openwrt 路由上开启BBR</title>
      <link href="/posts/2019-12-24-46437.html"/>
      <url>/posts/2019-12-24-46437.html</url>
      
        <content type="html"><![CDATA[<p>BBR 是一种协议算法，在 Openwrt 路由上启用 BBR 还是有一定作用的。 Openwrt 18.* 后都自带模块 <code>kmod-tcp-bbr</code> 安装就可以。</p><a id="more"></a><p><img src="/images/posts/Openwrt-BBR.jpg" alt="Openwrt-BBR"><br>看内核版本</p><pre><code>root@OpenWrt:~# uname -r4.9.184</code></pre><p>安装 <code>kmod-tcp-bbr</code></p><pre><code>opkg updateopkg install kmod-tcp-bbr</code></pre><p>会安装相关的 ipk</p><pre><code>Configuring kmod-sched-core.Configuring kmod-sched.Configuring kmod-tcp-bbr.</code></pre><p>查看相关情况</p><pre><code>root@OpenWrt:~# sysctl net.ipv4.tcp_congestion_controlnet.ipv4.tcp_congestion_control = cubicroot@OpenWrt:~# sysctl net.ipv4.tcp_available_congestion_controlnet.ipv4.tcp_available_congestion_control = cubic reno bbrroot@OpenWrt:~# sysctl net.core.default_qdiscnet.core.default_qdisc = fq_codelroot@OpenWrt:~# lsmod | grep bbrtcp_bbr                 4832  0root@OpenWrt:~# cat /etc/sysctl.conf# Defaults are configured in /etc/sysctl.d/* and can be customized in this fileroot@OpenWrt:~# ls -l /etc/sysctl.d/-rw-r--r--    1 root     root           675 Jun 27 12:18 10-default.conf-rw-r--r--    1 root     root           379 Jun 27 12:18 11-nf-conntrack.conf-rw-r--r--    1 root     root           184 Jun 27 12:18 12-tcp-bbr.confroot@OpenWrt:~# cat /etc/sysctl.d/12-tcp-bbr.conf# Do not edit, changes to this file will be lost on upgrades# /etc/sysctl.conf can be used to customize sysctl settingsnet.ipv4.tcp_congestion_control=bbrnet.core.default_qdisc=fqroot@OpenWrt:~# sysctl -proot@OpenWrt:~# lsmod | grep bbrtcp_bbr                 4832  0</code></pre><p>还没生效，重启路由后再看看</p><pre><code>root@OpenWrt:~# lsmod | grep bbrtcp_bbr                 4832 21root@OpenWrt:~# sysctl net.ipv4.tcp_congestion_controlnet.ipv4.tcp_congestion_control = bbr</code></pre><p>BBR 加速生效了！</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenWrt </tag>
            
            <tag> BBR </tag>
            
            <tag> 路由 </tag>
            
            <tag> 开启 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim 与中文输入法</title>
      <link href="/posts/2019-12-21-21047.html"/>
      <url>/posts/2019-12-21-21047.html</url>
      
        <content type="html"><![CDATA[<p>我最后还是放弃把 Vim 作为主要编辑器来输入中文了，整体使用下来 mental model 的 cost 太重了。<a id="more"></a>记笔记时用用中文呀或者改改博客时偶尔用一下还<br>蛮去，这个时候这个功能至少能帮助你 Esc 之后不煞笔，所以也不算完全没有价值吧……</p><hr><p>我相信很多中文世界的 Vimer 都遇到过这个烦恼，在 vim 的 insert 模式时可能突然想输个中文，输完之后会本能的直接 <code>esc</code> 接 normal 模式操作，结果发现<br>跳出来的是中文输入法……对于 vscode，我一般会在几次错误之后被逼到退出 vscode vim 模式，而对于终端中用的 neovim，就只能尽量不输入中文了。</p><p>为了满足我 1% 用 vim 输入中文的场景（比如写博客），我还是想看看有没有什么解决方案，Google 出来的解决方案基本是：<em>在退出 insert 模式时记住当时的<br>输入法，并自动切换到默认输入法（一般是英文）给 normal 模式用，并且在下一次进入 insert 模式时再切换回来。</em></p><p>原生 vim 的话，可以使用 <a href="https://github.com/ybian/smartim" target="_blank" rel="noopener">smartim</a> 插件，原理是调用 <a href="https://github.com/daipeihust/im-select" target="_blank" rel="noopener">im-select</a> 这个 CLI 工具来切换输入法。</p><p>对于 VSCode-vim 的话，smartim 的移植也在近期的 PR 中被 merge 到了插件里，<a href="https://github.com/VSCodeVim/Vim#use-im-select" target="_blank" rel="noopener">详情见文档的这部分配置</a>，需要指定一下默认输入法和 im-select 的 binary 路径就好。</p><hr><p>不过实话说，在 vim 中编辑中文的效率和体验和英文比都是大打折扣的。因为中文分词难度太高，不像英文可以简单依靠一个 <code>split &quot; &quot;</code> 搞定。所以其实无论 vim（<code>w</code>ord，<code>b</code>egin，<code>e</code>nd），emacs 还是操作系统自带的（比如 macOS 中的 <code>alt + 箭头</code>） 「按词移动」功能对于中文都仅仅是跳转到下一个空格处而已&gt;，对于中文来说基本就是下一句了……其他常用操作诸如 <code>f</code>，<code>/</code>, <code>r</code>eplace, <code>t</code>ill 也都无法很好的工作，基本只能靠 <code>hjkl</code> 爬行……</p><p>不过也算聊胜于无吧，由于我的主力外置键盘是 HHKB，能用 vim 操作的一个子集（<code>hjkl</code>, <code>o</code>, <code>A</code>, <code>I</code>, <code>v</code> etc.）可能也比按住 <code>Fn</code> 的方向键好用……</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vim </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown插入图片、视频和公式</title>
      <link href="/posts/2019-12-20-33346.html"/>
      <url>/posts/2019-12-20-33346.html</url>
      
        <content type="html"><![CDATA[<p>记录一些常用的Markdown插入图片和视频方法</p><a id="more"></a><h2 id="1-Markdown-插入图片的几种方法"><a href="#1-Markdown-插入图片的几种方法" class="headerlink" title="1. Markdown 插入图片的几种方法"></a>1. Markdown 插入图片的几种方法</h2><h3 id="1-1-原-markdown-语法"><a href="#1-1-原-markdown-语法" class="headerlink" title="1.1 原 markdown 语法"></a>1.1 原 markdown 语法</h3><pre><code class="markdown">![这是图片描述](这是图片链接)</code></pre><h3 id="1-2-html-语法"><a href="#1-2-html-语法" class="headerlink" title="1.2 html 语法"></a>1.2 html 语法</h3><pre><code class="html">&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shw2018/cdn/master/blog_files/img/PicGo-Github-PicBed/2.png&quot; &gt;&lt;/p&gt;</code></pre><h2 id="2-插入音乐-以网易云音乐为例"><a href="#2-插入音乐-以网易云音乐为例" class="headerlink" title="2. 插入音乐,以网易云音乐为例"></a>2. 插入音乐,以网易云音乐为例</h2><p>例1：</p><pre><code class="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=450 src=&quot;//music.163.com/outchain/player?type=0&amp;id=2737308121&amp;auto=1&amp;height=430&quot;&gt;&lt;/iframe&gt;</code></pre><p>效果：</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=450 src="//music.163.com/outchain/player?type=0&id=2737308121&auto=1&height=430"></iframe><h2 id="3-几种文章内视频插入的方法"><a href="#3-几种文章内视频插入的方法" class="headerlink" title="3. 几种文章内视频插入的方法"></a>3. 几种文章内视频插入的方法</h2><p>例1：</p><pre><code class="html">&lt;video width=&quot;100%&quot; height=100% src=&quot;https://yanghexo.cn-bj.ufileos.com/github.mp4&quot; controls=&quot;controls&quot; poster=&quot;https://yanghexo.cn-bj.ufileos.com/github.jpg&quot; preload=&quot;auto&quot;&gt; &lt;/video&gt;</code></pre><p>效果：</p><p><video width="100%" height=100% src="https://yanghexo.cn-bj.ufileos.com/github.mp4" controls="controls" poster="https://yanghexo.cn-bj.ufileos.com/github.jpg" preload="auto"> </video></p><p>例二：<br>需要先装一个插件：<code>npm install hexo-tag-dplayer --save</code></p><pre><code>{% dplayer "url=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.mp4" "addition=https://dplayer.daoapp.io/bilibili?aid=4157142" "api=https://api.prprpr.me/dplayer/" "pic=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.jpg" "id=9E2E3368B56CDBB4" "loop=yes" "theme=#FADFA3" "autoplay=false" "token=tokendemo" %} {% dplayer 'url=some.mp4' "id=someid" "api=https://api.prprpr.me/dplayer/" "addition=/some.json" 'code=player.on("loadstart",function(){console.log("loadstart")})' "autoplay" %}</code></pre><p>效果：</p><p>例三：</p><p>iframe内嵌哔哩哔哩视频播放</p><pre><code class="html">&lt;iframe width=&quot;100%&quot; height=&quot;100%&quot; src=&quot;//player.bilibili.com/player.html?aid=52012946&amp;cid=91055960&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;</code></pre><iframe width="100%" height="500px" src="//player.bilibili.com/player.html?aid=52012946&cid=91055960&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><hr><p>参数说明：</p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>autoplay</td><td><em>autoplay</em></td><td>如果出现该属性，则视频在就绪后马上播放。</td></tr><tr><td>controls</td><td><em>controls</em></td><td>如果出现该属性，则向用户显示控件，比如播放按钮。</td></tr><tr><td>width</td><td><em>pixels</em></td><td>设置视频播放器的宽度。</td></tr><tr><td>height</td><td><em>pixels</em></td><td>设置视频播放器的高度。</td></tr><tr><td>loop</td><td><em>loop</em></td><td>如果出现该属性，则当媒介文件完成播放后再次开始播放。</td></tr><tr><td>multed</td><td>_multed</td><td>如果出现该属性，视频的音频输出为静音。</td></tr><tr><td>poster</td><td><em>URL</em></td><td>规定视频正在下载时显示的图像，直到用户点击播放按钮。</td></tr><tr><td>srv</td><td><em>URL</em></td><td>要播放的视频的 URL。</td></tr><tr><td>preload</td><td><em>auto metadata none</em></td><td>如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td></tr></tbody></table><ul><li>例子：</li></ul><pre><code>$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，行内公式示例} $</code></pre><p>显示：<br>$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，行内公式示例} $</p><ul><li>例子：</li></ul><pre><code class="mathematical">$$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，独立公式示例} $$</code></pre><p>显示：<br>$$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，独立公式示例<br>} $$</p><ul><li>例子：</li></ul><pre><code class="mathematical">$$ f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right) $$</code></pre><p>显示：<br>$$ f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right) $$</p><ul><li>例子：</li></ul><pre><code class="mathematical">$$\frac{a-1}{b-1} \quad and \quad {a+1\over b+1}$$</code></pre><p>显示：<br>$$\frac{a-1}{b-1} \quad and \quad {a+1\over b+1}$$</p><p>例子：</p><pre><code class="mathematical">$$f(x_1,x_2,\underbrace{\ldots}_{\rm ldots} ,x_n) = x_1^2 + x_2^2 + \underbrace{\cdots}_{\rm cdots} + x_n^2$$</code></pre><p>显示：<br>$$f(x_1,x_2,\underbrace{\ldots}<em>{\rm ldots} ,x_n) = x_1^2 + x_2^2 + \underbrace{\cdots}</em>{\rm cdots} + x_n^2$$</p><p>例子：</p><pre><code class="mathematical">$$d = \sqrt{(x_2-x_1)^2+(y_2-y_1)^2},|X|=\sqrt{x_2^2+y_2^2}.$$</code></pre><p>显示：</p><p>$$<br>d = \sqrt{(x_2-x_1)^2+(y_2-y_1)^2},|X|=\sqrt{x_2^2+y_2^2}.<br>$$</p><p>例子：</p><pre><code class="mathematical">$$d = \sqrt{(x_2-x_1)^2+(y_2-y_1)^2+(z_2-z_1)^2},|X|=\sqrt{x_2^2+y_2^2+z_2^2}.$$</code></pre><p>显示：<br>$$<br>d = \sqrt{(x_2-x_1)^2+(y_2-y_1)^2+(z_2-z_1)^2},|X|=\sqrt{x_2^2+y_2^2+z_2^2}.<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 写作 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
