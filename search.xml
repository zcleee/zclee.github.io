<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在前端页面中使用@font-face来显示web自定义字体</title>
      <link href="/posts/2020-02-11-748.html"/>
      <url>/posts/2020-02-11-748.html</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.w3.org/TR/css3-fonts/" target="_blank" rel="noopener">@font-face</a>是<a href="http://www.w3.org/TR/CSS/#css3" target="_blank" rel="noopener">CSS3</a>中的一个模块，他主要是把自己定义的Web字体嵌入到你的网页中，随着<a href="http://www.w3.org/TR/css3-fonts/" target="_blank" rel="noopener">@font-face</a>模块的出现，我们在Web的开发中使用字体不怕只能使用Web安全字体，你们当中或许有许多人会不自然的问，这样的东西IE能支持吗？当我告诉大家<a href="http://www.w3.org/TR/css3-fonts/" target="_blank" rel="noopener">@font-face</a>这个功能早在IE4就支持了你肯定会感到惊讶。我的Blog就使用了许多这样的自定义Web字体，比如说首页的Logo，Tags以及页面中的手写英文体，很多朋友问我如何使用，能让自己的页面也支持这样的自定义字体，一句话这些都是<a href="http://www.w3.org/TR/css3-fonts/" target="_blank" rel="noopener">@font-face</a>实现的，为了能让更多的朋友知道如何使用他，今天我主要把自己的一点学习过程贴上来和大家分享。</p><p>首先我们一起来看看@font-face的语法规则：</p><pre><code class="css">@font-face {   font-family: &lt;YourWebFontName&gt;;   src: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*;   [font-weight: &lt;weight&gt;];   [font-style: &lt;style&gt;]; }</code></pre><p><strong>取值说明</strong></p><p>1、YourWebFontName:此值指的就是你自定义的字体名称，最好是使用你下载的默认字体，他将被引用到你的Web元素中的font-family。如“font-family:”YourWebFontName”;”</p><p>2、source:此值指的是你自定义的字体的存放路径，可以是相对路径也可以是绝路径；</p><p>3、format：此值指的是你自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型：truetype,opentype,truetype-aat,embedded-opentype,avg等；</p><p>4、weight和style:这两个值大家一定很熟悉，weight定义字体是否为粗体，style主要定义字体样式，如斜体。</p><p><strong>兼容浏览器</strong></p><p><img src="/images/posts/font-face-browers.jpg" alt=""></p><p>说到浏览器对@font-face的兼容问题，这里涉及到一个字体format的问题，因为不同的浏览器对字体格式支持是不一致的，这样大家有必要了解一下，各种版本的浏览器支持什么样的字体，前面也简单带到了有关字体的几种格式，下面我就分别说一下这个问题，让大家心里有一个概念：</p><p><strong>一、TureTpe(.ttf)格式：</strong></p><p>.ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，因此他不为网站优化,支持这种字体的浏览器有【IE9+,Firefox3.5+,Chrome4+,Safari3+,Opera10+,iOS Mobile Safari4.2+】；</p><p><strong>二、OpenType(.otf)格式：</strong></p><p>.otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，所以也提供了更多的功能,支持这种字体的浏览器有【Firefox3.5+,Chrome4.0+,Safari3.1+,Opera10.0+,iOS Mobile Safari4.2+】；</p><p><strong>三、Web Open Font Format(.woff)格式：</strong></p><p>.woff字体是Web字体中最佳格式，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离,支持这种字体的浏览器有【IE9+,Firefox3.5+,Chrome6+,Safari3.6+,Opera11.1+】；</p><p><strong>四、Embedded Open Type(.eot)格式：</strong></p><p>.eot字体是IE专用字体，可以从TrueType创建此格式字体,支持这种字体的浏览器有【IE4+】；</p><p><strong>五、SVG(.svg)格式：</strong></p><p>.svg字体是基于SVG字体渲染的一种格式,支持这种字体的浏览器有【Chrome4+,Safari3.1+,Opera10.0+,iOS Mobile Safari3.2+】。</p><p>这就意味着在@font-face中我们至少需要.woff,.eot两种格式字体，甚至还需要.svg等字体达到更多种浏览版本的支持。</p><p>为了使@font-face达到更多的浏览器支持，<a href="http://paulirish.com/" target="_blank" rel="noopener">Paul Irish</a>写了一个独特的@font-face语法叫<a href="http://paulirish.com/2009/bulletproof-font-face-implementation-syntax/" target="_blank" rel="noopener">Bulletproof @font-face</a>:</p><pre><code class="css">@font-face { font-family: &#39;YourWebFontName&#39;; src: url(&#39;YourWebFontName.eot?&#39;) format(&#39;eot&#39;);/*IE*/ src:url(&#39;YourWebFontName.woff&#39;) format(&#39;woff&#39;), url(&#39;YourWebFontName.ttf&#39;) format(&#39;truetype&#39;);/*non-IE*/}</code></pre><p>但为了让各多的浏览器支持，你也可以写成：</p><pre><code class="css">@font-face { font-family: &#39;YourWebFontName&#39;; src: url(&#39;YourWebFontName.eot&#39;); /* IE9 Compat Modes */ src: url(&#39;YourWebFontName.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;), /* IE6-IE8 */          url(&#39;YourWebFontName.woff&#39;) format(&#39;woff&#39;), /* Modern Browsers */          url(&#39;YourWebFontName.ttf&#39;)  format(&#39;truetype&#39;), /* Safari, Android, iOS */          url(&#39;YourWebFontName.svg#YourWebFontName&#39;) format(&#39;svg&#39;); /* Legacy iOS */}</code></pre><p>说了这么多空洞的理论知识，大家一定有点心痒痒了，那么我们先来看看W3CPLUS首页中导航部分的兰色字体是如何实现的，假如我们有一个这样的DOM标签，需要应用自定义字体：</p><p><strong>HTML Code:</strong></p><pre><code class="css"> &lt;h2 class=&quot;neuesDemo&quot;&gt;Neues Bauen Demo&lt;/h2&gt;</code></pre><p>通过@font-face来定义自己的Web Font:</p><pre><code class="css">@font-face {  font-family: &#39;NeuesBauenDemo&#39;;  src: url(&#39;../fonts/neues_bauen_demo-webfont.eot&#39;);  src: url(&#39;../fonts/neues_bauen_demo-webfont.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),   url(&#39;../fonts/neues_bauen_demo-webfont.woff&#39;) format(&#39;woff&#39;),   url(&#39;../fonts/neues_bauen_demo-webfont.ttf&#39;) format(&#39;truetype&#39;),   url(&#39;../fonts/neues_bauen_demo-webfont.svg#NeuesBauenDemo&#39;) format(&#39;svg&#39;);  font-weight: normal;  font-style: normal;}</code></pre><p>我在这里采用的是相对路径，当然大家也可以使用绝路径。到这里我们就需要把定义好的字体应用到我们实际页面中去：</p><pre><code class="css">h2.neuesDemo {   font-family: &#39;NeuesBauenDemo&#39;}</code></pre><p><strong>效果：</strong></p><p><img src="/images/posts/neues-bauen-demo.jpg" alt=""></p><p>看到上面的效果，我想大家会感到@font-face很神奇，同时也想争着做做看，可是一动手才发现，特殊字体我要怎样才能得到，那些.eot,.woff,.ttf,.svg这些字体格式又怎么获取呢？有些朋友可能就不知道如何运手了，那么我们就带着这些问题来一个全程完成的实例吧：</p><p><strong>一、获取特殊字体：</strong></p><p>我们拿下面这种single Malta字体来说吧：</p><p><img src="/images/posts/font-face-single-malta-demo.jpg" alt=""></p><p>要得到single Malta字体，不外乎两种途径，其一找到付费网站购买字体，其二就是到免费网站DownLoad字体。当然要给钱的这种傻事我想大家都不会做的，那我们就得到免费的地方下载，在哪有呢？我平时都是到<a href="http://www.google.com/webfonts" target="_blank" rel="noopener">Google Web Fonts</a>和<a href="http://www.dafont.com/" target="_blank" rel="noopener">Dafont.com</a>寻找自己需要的字体，当然网上也还有别的下载字体的地方，这个Demo使用的是<a href="http://www.dafont.com/" target="_blank" rel="noopener">Dafont.com</a>的Single Malta字体，这样就可以到这里下载<a href="http://www.dafont.com/single-malta.font" target="_blank" rel="noopener">Single Malta</a>：</p><p><img src="/images/posts/single-malta-font.jpg" alt=""></p><p>Single Malta下载下来后，需要把它解压缩出来：</p><p><img src="/images/posts/single-malta-font-out.jpg" alt=""></p><p><strong>二、获取@font-face所需字体格式：</strong></p><p>特殊字体已经在你的电脑中了，现在我们需要想办法获得@font-face所需的.eot,.woff,.ttf,.svg字体格式。要获取这些字体格式，我们同样是需要第三方工具或者软件来实现，下面我给大家推荐一款我常用的一个工具<a href="http://www.fontsquirrel.com/fontface/generator" target="_blank" rel="noopener">fontsquirrel</a>,别的先不多说，首跟我点<a href="http://www.fontsquirrel.com/fontface/generator" target="_blank" rel="noopener">这里</a>进入到下面这个界面吧。</p><p><img src="/images/posts/font-face-kit-generator.png" alt=""></p><p>如果你进入页面没有看到上图，你可以直接点击导航:</p><p><img src="/images/posts/fontsquirrel-menu.jpg" alt=""></p><p>如果你看到了上面的界面，那就好办了，我们来看如何应用这个工具生成@font-face需要的各种字体，先把我们刚才下载的字体上传上去：</p><p><img src="/images/posts/add-fonts.jpg" alt=""></p><p>上传后按下图所示操作：</p><p><img src="/images/posts/font-download.png" alt=""></p><p>现在从Font Squirrel下载下来的文件已经保存在你本地的电脑上了，接着只要对他进行解压缩，你就能看到文件列表如下所示：</p><p><img src="/images/posts/font-format.jpg" alt=""></p><p>大家可以看到，解压缩出来的文件格式，里面除了@font-face所需要的字体格式外，还带有一个DEMO文件，如果你不清楚的也可以参考下载下来的DEMO文件，我在这里不对DEMO说明问题，我主要是给大家介绍如何把下载下来的文件有价值的运用到我们的项目中。</p><p>例如在自己的本地创建了一个fontface项目：</p><p><img src="/images/posts/font-face-project.jpg" alt=""></p><p>为了让项目结构更清晰，我们在项目中单独创建一个fonts目录，用来放置解压缩出来@font-face所需的字体格式：</p><p><img src="/images/posts/font-face-project-demo.jpg" alt=""></p><p>现在@font-face所需字体已经加载到本地项目，现在本地项目中的style.css中附上我们需要的@font-face样式</p><pre><code class="css">@font-face {   font-family: &#39;SingleMaltaRegular&#39;;   src: url(&#39;../fonts/singlemalta-webfont.eot&#39;);   src: url(&#39;../fonts/singlemalta-webfont.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),        url(&#39;../fonts/singlemalta-webfont.woff&#39;) format(&#39;woff&#39;),    url(&#39;../fonts/singlemalta-webfont.ttf&#39;) format(&#39;truetype&#39;),    url(&#39;../fonts/singlemalta-webfont.svg#SingleMaltaRegular&#39;) format(&#39;svg&#39;);   font-weight: normal;   font-style: normal;}</code></pre><p>到这里为止，我们已经通过@font-face自定义好所需的SingleMalta字体，离最后效果只差一步了，就是把自己定义的字体应用到你的Web中的DOM元素上：</p><pre><code class="css">h2.singleMalta {  font-family: &#39;SingleMaltaRegular&#39;}</code></pre><p><strong>效果：</strong></p><p><img src="/images/posts/single-malta-font-demo.jpg" alt=""></p><p>看到上面的效果，那大家就知道我们实现成功了。那么关于@font-face帮你打造特殊效果的字体，到这里基本上就完成了，我在这里需要提醒使用者：</p><p>1、如果你的项目中是英文网站，而且项目中的Logo，Tags等应用到较多的这种特殊字体效果，我建议你不要使用图片效果，而使用@font-face，但是你是中文网站，我觉得还是使用图片比较合适，因为加载英文字体和图片没有多大区别，但是你加载中文字体，那就不一样了，因为中文字体太大了，这样会影响到项目的某些性能的优化；</p><p>2、致命的错误，你在@font-face中定义时，文件路径没有载对；</p><p>3、你只定义了@font-face，但并没有应用到你的项目中的DOM元素上；</p><p>以上几点都是在平时制作中常出现的问题，希望大家能小意一些，另外我们没有办法在购买所有字体，就算你实力雄厚，那也没有办法在一台服务器主机上放置你所有项目需要的字体。因此我给大家提供几个免费字体下载的网址：<a href="http://webfonts.fonts.com/" target="_blank" rel="noopener">Webfonts</a>,<a href="http://typekit.com/" target="_blank" rel="noopener">Typekit</a>,<a href="http://kernest.com/" target="_blank" rel="noopener">Kernest</a>,<a href="http://www.google.com/webfonts" target="_blank" rel="noopener">Google Web Fonts</a>,<a href="http://kernest.com/licenses" target="_blank" rel="noopener">Kernest</a>,<a href="http://www.dafont.com/" target="_blank" rel="noopener">Dafont</a>,<a href="http://nicewebtype.com/fonts/" target="_blank" rel="noopener">Niec Web Type</a>,不然你点<a href="http://www.google.com/search?q=webfonts" target="_blank" rel="noopener">这里</a>将有更多的免费字体。前面几个链接是帮助你获取一些优美的怪异的特殊字体，但下面这个工具作用更是无穷的大，他能帮你生成@font-face所需要的各种字体，这工具就是<a href="http://www.fontsquirrel.com/fontface/generator" target="_blank" rel="noopener">Font Squirrel</a>。</p><p><strong>最后在提醒一下，使用@font-face别的可以忘了，但<a href="http://www.fontsquirrel.com/fontface/generator" target="_blank" rel="noopener">Font Squirrel</a>千万不能忘，因为他能帮你生成@font-face所需的各种字体格式。</strong></p><p>到此关于@font-face就介绍完了，不知道大家喜欢不喜欢，如果喜欢的话赶快动手实践一下，有Blog的可以马上运用上去，也可以炫一下。</p><p><strong>2014年03月更新—</strong>—@font-face无法在Firefox下正常工作的解决方案，详细的请点击：<a href="http://stackoverflow.com/questions/2856502/css-font-face-not-working-with-firefox-but-working-with-chrome-and-ie" target="_blank" rel="noopener">http://stackoverflow.com/questions/2856502/css-font-face-not-working-with-firefox-but-working-with-chrome-and-ie</a></p><p>本文转自<a href="http://www.w3cplus.com/" target="_blank" rel="noopener">W3CPLUS</a> 的《<a href="http://www.w3cplus.com/content/css3-font-face" target="_blank" rel="noopener">CSS @font-face</a>》<br>如需转载烦请注明出处：<a href="http://www.w3cplus.com/" target="_blank" rel="noopener">W3CPLUS</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 字体 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python实现加密方法合集</title>
      <link href="/posts/2020-01-08-6575.html"/>
      <url>/posts/2020-01-08-6575.html</url>
      
        <content type="html"><![CDATA[<p>我们所说的加密方式，都是对二进制编码的格式进行加密的，对应到Python中，则是我们的Bytes。所以当我们在Python中进行加密操作的时候，要确保我们操作的是Bytes，否则就会报错。</p><a id="more"></a><p><img src="/images/posts/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.jpg" alt="对称加密算法"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>明文：明文是指没有经过加密的数据。一般而言，明文都是等待传输的数据。由于没有经过加密，明文很容易被识别与破解，因此在传输明文之前必须进行加密处理。</li><li>密文：密文只是明文经过某种加密算法而得到的数据，通常密文的形式复杂难以识别及理解。</li><li>密钥：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。</li><li>对称加密：通信双方同时掌握一个密钥，加密解密都是由一个密钥完成的（即加密密钥等于解密密钥，加解密密钥可以相互推倒出来）。双方通信前共同拟定一个密钥，不对第三方公开。</li><li>分组加密：分组密码是将明文分成固定长度的组，每一组都采用同一密钥和算法进行加密，输出也是固定长度的密文。</li></ul><h2 id="加密算法分类"><a href="#加密算法分类" class="headerlink" title="加密算法分类"></a>加密算法分类</h2><h3 id="对称加密算法："><a href="#对称加密算法：" class="headerlink" title="对称加密算法："></a>对称加密算法：</h3><p>对称加密采用了对称密码编码技术，它的特点是文件加密和解密使用相同的密钥</p><p>发送方和接收方需要持有同一把密钥，发送消息和接收消息均使用该密钥。</p><p>相对于非对称加密，对称加密具有更高的加解密速度，但双方都需要事先知道密钥，密钥在传输过程中可能会被窃取，因此安全性没有非对称加密高。</p><p>常见的对称加密算法：DES，AES，3DES等等</p><h3 id="非对称加密算法："><a href="#非对称加密算法：" class="headerlink" title="非对称加密算法："></a>非对称加密算法：</h3><p>文件加密需要公开密钥（publickey）和私有密钥（privatekey）。</p><p>接收方在发送消息前需要事先生成公钥和私钥，然后将公钥发送给发送方。发送放收到公钥后，将待发送数据用公钥加密，发送给接收方。接收到收到数据后，用私钥解密。</p><p>在这个过程中，公钥负责加密，私钥负责解密，数据在传输过程中即使被截获，攻击者由于没有私钥，因此也无法破解。</p><p>非对称加密算法的加解密速度低于对称加密算法，但是安全性更高。</p><p>非对称加密算法：RSA、DSA、ECC等算法</p><h3 id="消息摘要算法："><a href="#消息摘要算法：" class="headerlink" title="消息摘要算法："></a>消息摘要算法：</h3><p>消息摘要算法可以验证信息是否被篡改。</p><p>在数据发送前，首先使用消息摘要算法生成该数据的签名，然后签名和数据一同发送给接收者。</p><p>接收者收到数据后，对收到的数据采用消息摘要算法获得签名，最后比较签名是否一致，以此来判断数据在传输过程中是否发生修改。</p><h2 id="Python实现加密方法合集"><a href="#Python实现加密方法合集" class="headerlink" title="Python实现加密方法合集"></a>Python实现加密方法合集</h2><pre><code class="python"># -*- coding：utf-8 -*-import base64import rsafrom Crypto.Cipher import AESfrom Crypto.PublicKey import RSAfrom pyDes import des, CBC, PAD_PKCS5from Crypto.Cipher import DES3import hashlibimport hmacclass USE_AES:    &quot;&quot;&quot;    AES    除了MODE_SIV模式key长度为：32, 48, or 64,    其余key长度为16, 24 or 32    详细见AES内部文档    CBC模式传入iv参数    本例使用常用的ECB模式    &quot;&quot;&quot;    def __init__(self, key):        if len(key) &gt; 32:            key = key[:32]        self.key = self.to_16(key)    def to_16(self, key):        &quot;&quot;&quot;        转为16倍数的bytes数据        :param key:        :return:        &quot;&quot;&quot;        key = bytes(key, encoding=&quot;utf8&quot;)        while len(key) % 16 != 0:            key += b&#39;\0&#39;        return key  # 返回bytes    def aes(self):        return AES.new(self.key, AES.MODE_ECB) # 初始化加密器    def encrypt(self, text):        aes = self.aes()        return str(base64.encodebytes(aes.encrypt(self.to_16(text))),                   encoding=&#39;utf8&#39;).replace(&#39;\n&#39;, &#39;&#39;)  # 加密    def decodebytes(self, text):        aes = self.aes()        return str(aes.decrypt(base64.decodebytes(bytes(            text, encoding=&#39;utf8&#39;))).rstrip(b&#39;\0&#39;).decode(&quot;utf8&quot;))  # 解密class USE_RSA:    &quot;&quot;&quot;    生成密钥可保存.pem格式文件    1024位的证书，加密时最大支持117个字节，解密时为128；    2048位的证书，加密时最大支持245个字节，解密时为256。    加密大文件时需要先用AES或者DES加密，再用RSA加密密钥，详细见文档    文档:https://stuvel.eu/files/python-rsa-doc/usage.html#generating-keys    &quot;&quot;&quot;    def __init__(self, number=1024):        &quot;&quot;&quot;        :param number: 公钥、私钥        &quot;&quot;&quot;        self.pubkey, self.privkey = rsa.newkeys(number)    def rsaEncrypt(self, text):        &quot;&quot;&quot;        :param test: str        :return: bytes        &quot;&quot;&quot;        content = text.encode(&#39;utf-8&#39;)        crypto = rsa.encrypt(content, self.pubkey)        return crypto    def rsaDecrypt(self, text):        &quot;&quot;&quot;        :param text:bytes         :return: str        &quot;&quot;&quot;        content = rsa.decrypt(text, self.privkey)        con = content.decode(&#39;utf-8&#39;)        return con    def savePem(self, path_name, text):        &quot;&quot;&quot;        :param path_name: 保存路径        :param text: str        :return:bytes        &quot;&quot;&quot;        if &quot;PEM&quot; in path_name.upper():            path_name = path_name[:-4]        with open(&#39;{}.pem&#39;.format(path_name), &#39;bw&#39;) as f:            f.write(text.save_pkcs1())    def readPem(self, path_name, key_type):        &quot;&quot;&quot;        :param path_name: 密钥文件        :param key_type:类型         :return:         &quot;&quot;&quot;        if &#39;pubkey&#39; in key_type:            self.pubkey = rsa.PublicKey.load_pkcs1(path_name)        else:            self.privkey = rsa.PublicKey.load_pkcs1(path_name)        return True    def sign(self, message, priv_key=None, hash_method=&#39;SHA-1&#39;):        &quot;&quot;&quot;        生成明文的哈希签名以便还原后对照        :param message: str        :param priv_key:        :param hash_method: 哈希的模式        :return:        &quot;&quot;&quot;        if None == priv_key:            priv_key = self.privkey        return rsa.sign(message.encode(), priv_key, hash_method)    def checkSign(self, mess, result, pubkey=None):        &quot;&quot;&quot;        验证签名：传入解密后明文、签名、公钥，验证成功返回哈希方法，失败则报错        :param mess: str        :param result: bytes        :param pubkey:         :return: str        &quot;&quot;&quot;        if None == pubkey:            pubkey = self.privkey        try:            result = rsa.verify(mess, result, pubkey)            return result        except:            return Falseclass USE_DES:    &quot;&quot;&quot;    des(key,[mode], [IV], [pad], [pad mode])    key:必须正好8字节    mode（模式）：ECB、CBC    iv:CBC模式中必须提供长8字节    pad:填充字符    padmode:加密填充模式PAD_NORMAL or PAD_PKCS5    &quot;&quot;&quot;    def __init__(self, key, iv):        if not isinstance(key, bytes):            key = bytes(key, encoding=&quot;utf8&quot;)        if not isinstance(iv, bytes):            iv = bytes(iv, encoding=&quot;utf8&quot;)        self.key = key        self.iv = iv    def encrypt(self, text):        &quot;&quot;&quot;        DES 加密        :param text: 原始字符串        :return: 加密后字符串，bytes        &quot;&quot;&quot;        if not isinstance(text, bytes):            text = bytes(text, &quot;utf-8&quot;)        secret_key = self.key        iv = self.iv        k = des(secret_key, CBC, iv, pad=None, padmode=PAD_PKCS5)        en = k.encrypt(text, padmode=PAD_PKCS5)        return en    def descrypt(self, text):        &quot;&quot;&quot;        DES 解密        :param text: 加密后的字符串，bytes        :return:  解密后的字符串        &quot;&quot;&quot;        secret_key = self.key        iv = self.iv        k = des(secret_key, CBC, iv, pad=None, padmode=PAD_PKCS5)        de = k.decrypt(text, padmode=PAD_PKCS5)        return de.decode()class USE_DES3:    &quot;&quot;&quot;    new(key, mode, *args, **kwargs)    key:必须8bytes倍数介于16-24    mode：    iv:初始化向量适用于MODE_CBC、MODE_CFB、MODE_OFB、MODE_OPENPGP，4种模式        ``MODE_CBC``, ``MODE_CFB``, and ``MODE_OFB``长度为8bytes        ```MODE_OPENPGP```加密时8bytes解密时10bytes        未提供默认随机生成    nonce：仅在 ``MODE_EAX`` and ``MODE_CTR``模式中使用            ``MODE_EAX``建议16bytes            ``MODE_CTR``建议[0, 7]长度            未提供则随机生成    segment_size：分段大小，仅在 ``MODE_CFB``模式中使用，长度为8倍数，未指定则默认为8    mac_len： 适用``MODE_EAX``模式，身份验证标记的长度（字节），它不能超过8（默认值）    initial_value：适用```MODE_CTR```，计数器的初始值计数器块。默认为**0**。    &quot;&quot;&quot;    def __init__(self, key):        self.key = key        self.mode = DES3.MODE_ECB    def encrypt(self, text):        &quot;&quot;&quot;        传入明文        :param text:bytes类型，长度是KEY的倍数        :return:        &quot;&quot;&quot;        if not isinstance(text, bytes):            text = bytes(text, &#39;utf-8&#39;)        x = len(text) % 8        text = text+b&#39;\0&#39;*x        cryptor = DES3.new(self.key, self.mode)        ciphertext = cryptor.encrypt(text)        return ciphertext    def decrypt(self, text):        cryptor = DES3.new(self.key, self.mode)        plain_text = cryptor.decrypt(text)        st = str(plain_text.decode(&quot;utf-8&quot;)).rstrip(&#39;\0&#39;)        return stdef USE_MD5(test):    if not isinstance(test, bytes):        test = bytes(test, &#39;utf-8&#39;)    m = hashlib.md5()    m.update(test)    return m.hexdigest()def USE_HMAC(key, text):    if not isinstance(key, bytes):        key = bytes(key, &#39;utf-8&#39;)    if not isinstance(text, bytes):        text = bytes(text, &#39;utf-8&#39;)    h = hmac.new(key, text, digestmod=&#39;MD5&#39;)    return h.hexdigest()def USE_SHA(text):    if not isinstance(text, bytes):        text = bytes(text, &#39;utf-8&#39;)    sha = hashlib.sha1(text)    encrypts = sha.hexdigest()    return encryptsif __name__ == &#39;__main__&#39;:    aes_test = USE_AES(&quot;assssssssdfasasasasa&quot;)    a = aes_test.encrypt(&quot;测试&quot;)    b = aes_test.decodebytes(a)    rsa_test = USE_RSA()    a = rsa_test.rsaEncrypt(&quot;测试加密&quot;)    b = rsa_test.rsaDecrypt(a)    des_test = USE_DES(b&quot;12345678&quot;, b&quot;12345678&quot;)    a = des_test.encrypt(&quot;测试加密&quot;)    b = des_test.descrypt(a)    des3_test = USE_DES3(b&quot;123456789qazxswe&quot;)    a = des3_test.encrypt(&quot;测试加密&quot;)    b = des3_test.decrypt(a)    md5_test = USE_MD5(&quot;测试签名&quot;)    hmac_test = USE_HMAC(&quot;123456&quot;, &quot;测试&quot;)    sha_test = USE_SHA(&quot;测试加密&quot;)</code></pre><p>Github: <a href="https://github.com/dhfjcuff/R-A-M-D-D3-S-M-H/blob/master/RSA-AES-MD5-DES-DES3-MD5-SHA-HMAC.py" target="_blank" rel="noopener">https://github.com/dhfjcuff/R-A-M-D-D3-S-M-H/blob/master/RSA-AES-MD5-DES-DES3-MD5-SHA-HMAC.py</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 加密 </tag>
            
            <tag> 解密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写python脚本遍历文件夹并取指定后缀名文件</title>
      <link href="/posts/2019-12-29-25741.html"/>
      <url>/posts/2019-12-29-25741.html</url>
      
        <content type="html"><![CDATA[<p>用python来遍历某个文件并获取指定后缀名文件</p><a id="more"></a><h2 id="python-实现函数代码"><a href="#python-实现函数代码" class="headerlink" title="python 实现函数代码"></a>python 实现函数代码</h2><pre><code>suffix = &#39;.php&#39;def get_file_list(_dir):    i = 0    for root, dirs, files in os.walk(_dir):        for f in files:            f_path = os.path.join(root, f)            if f_path.endswith(suffix):                f_path2 = &#39;/&#39; + f_path.replace(_dir, &#39;&#39;).strip(&#39;/&#39;)                print f_path2</code></pre><h2 id="walk-函数"><a href="#walk-函数" class="headerlink" title="walk 函数"></a>walk 函数</h2><pre><code>os.walk() 方法是一个简单易用的文件、目录遍历器，可以帮助我们高效的处理文件、目录方面的事情。用于通过在目录树中游走输出在目录中的文件名，向上或者向下。</code></pre><h3 id="walk-语法"><a href="#walk-语法" class="headerlink" title="walk 语法"></a>walk 语法</h3><pre><code>os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])</code></pre><h3 id="walk-参数"><a href="#walk-参数" class="headerlink" title="walk 参数"></a>walk 参数</h3><ul><li>top – 是你所要遍历的目录的地址, 返回的是一个三元组(root,dirs,files)。<ul><li>root 所指的是当前正在遍历的这个文件夹的本身的地址</li><li>dirs 是一个 list ，内容是该文件夹中所有的目录的名字(不包括子目录)</li><li>files 同样是 list , 内容是该文件夹中所有的文件(不包括子目录)</li></ul></li><li>topdown –可选，为 True，则优先遍历 top 目录，否则优先遍历 top 的子目录(默认为开启)。如果 topdown 参数为 True，walk 会遍历top文件夹，与top 文件夹中每一个子目录。</li><li>onerror – 可选，需要一个 callable 对象，当 walk 需要异常时，会调用。</li><li>followlinks – 可选，如果为 True，则会遍历目录下的快捷方式(linux 下是软连接 symbolic link )实际所指的目录(默认关闭)，如果为 False，则优先遍历 top 的子目录。</li></ul><h3 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h3><ul><li>root: 返回给定根目录，但是在有下级文件夹时候会改变</li><li>dir:如果有个文件夹下面存在文件，就是返回为空，这个时候root不为空，我们可以这种方法来处理数据。</li><li>flies:如果不为空，就为底层文件。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 文件夹 </tag>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用国内pip 源</title>
      <link href="/posts/2019-12-28-9867.html"/>
      <url>/posts/2019-12-28-9867.html</url>
      
        <content type="html"><![CDATA[<p>有些服务器对外网络很坑，幸好国内有好多优秀的源镜像</p><a id="more"></a><p>优秀pip源推荐</p><pre><code>http://pypi.douban.com/  豆瓣http://pypi.hustunique.com/  华中理工大学http://pypi.sdutlinux.org/  山东理工大学http://pypi.mirrors.ustc.edu.cn/  中国科学技术大学</code></pre><pre><code>pip install web.py -i https://pypi.douban.com/simple</code></pre><p>~/.pip/pip.conf</p><pre><code>[global]index-url = https://pypi.douban.com/simple</code></pre><h2 id="清华大学开源镜像"><a href="#清华大学开源镜像" class="headerlink" title="清华大学开源镜像"></a>清华大学开源镜像</h2><p><a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/</a></p><p>临时使用</p><pre><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</code></pre><p>注意，<code>simple</code> 不能少, 是 <code>https</code> 而不是 <code>http</code></p><p>设为默认 升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置：</p><pre><code>pip install pip -Upip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pip </tag>
            
            <tag> 国内源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 用base64 对图片文件的编码和解码处理</title>
      <link href="/posts/2019-12-28-35102.html"/>
      <url>/posts/2019-12-28-35102.html</url>
      
        <content type="html"><![CDATA[<p>用base64 对图片文件的编码和解码处理</p><a id="more"></a><pre><code>import base64def convert(image):    f = open(image)    img_raw_data = f.read()    f.close()    img_b64_string = base64.b64encode(img_raw_data)    convert_img_raw_data = base64.b64decode(img_b64_string)    t = open(&quot;example.png&quot;, &quot;w+&quot;)    t.write(convert_img_raw_data)    t.close()if __name__ == &quot;__main__&quot;:    convert(&quot;test.png&quot;)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> base64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 根据字符串随机生成颜色</title>
      <link href="/posts/2019-12-28-38278.html"/>
      <url>/posts/2019-12-28-38278.html</url>
      
        <content type="html"><![CDATA[<p>遇到这么一个需求：根据用户名或用户id，随机生成一个颜色。其实就是用python 根据字符串随机生成颜色。</p><a id="more"></a><h2 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h2><p>下面是python 实现。</p><pre><code class="python">import hashlibdef hsv2rgb(h, s, v):    h += 0.618033988749895    h %= 1    h_i = int(h*6)    f = h*6 - h_i    p = v * (1 - s)    q = v * (1 - f*s)    t = v * (1 - (1 - f) * s)    if h_i == 0:        r, g, b = v, t, p    elif h_i == 1:        r, g, b = q, v, p    elif h_i == 2:        r, g, b = p, v, t    elif h_i == 3:        r, g, b = p, q, v    elif h_i == 4:        r, g, b = t, p, v    elif h_i == 5:        r, g, b = v, p, q    else:        r = g = b = 0    return [int(r*256), int(g*256), int(b*256)]def str2rgb(obj):    digest = hashlib.sha384(str(obj).encode(&#39;utf-8&#39;)).hexdigest()    sub_size = int(len(digest) / 3)    max_value = float(int(&quot;f&quot; * sub_size, 16))    digests = [digest[i * sub_size: (i + 1) * sub_size] for i in range(3)]    rgb = (((int(d, 16) / max_value)+0.618033988749895) % 1 for d in digests)    return &#39;#&#39; + &#39;&#39;.join([&quot;%02x&quot; % int(c*255 + 0.5 - 0.0000005) for c in rgb])def str2rgb2(obj):    digest = hashlib.sha384(str(obj).encode(&#39;utf-8&#39;)).hexdigest()    obj_value = int(digest, 16)    max_value = float(int(&quot;f&quot; * len(digest), 16))    rgb = hsv2rgb(obj_value/max_value, 0.5, 0.95)    return &#39;#&#39; + &#39;&#39;.join([&quot;%02x&quot; % c for c in rgb])</code></pre><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>上面有两种实现，其效果如下：<br><img src="/images/posts/str2rgb.png" alt="str2rgb.png"><br><img src="/images/posts/str2rgb2.png" alt="str2rgb2.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>第一种颜色较深，只要传入字符串不同，其颜色就不同。</li><li>第二种颜色较淡，过渡自然，但第二种只有732 种颜色。</li></ul><p>如果为了不同的颜色就使用第一种，如果允许相同的颜色，又要求柔和、自然接近，就考虑第二种。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 随机 </tag>
            
            <tag> 颜色 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python获取当前运行文件路径的方法</title>
      <link href="/posts/2019-12-28-18016.html"/>
      <url>/posts/2019-12-28-18016.html</url>
      
        <content type="html"><![CDATA[<p>下面是python获取当前运行文件路径的方法</p><a id="more"></a><h2 id="通过-file-获取"><a href="#通过-file-获取" class="headerlink" title="通过 file 获取"></a>通过 <strong>file</strong> 获取</h2><pre><code>os.path.dirname(os.path.realpath(__file__))</code></pre><h2 id="通过-getcwd-获取当前路径"><a href="#通过-getcwd-获取当前路径" class="headerlink" title="通过 getcwd 获取当前路径"></a>通过 getcwd 获取当前路径</h2><pre><code>os.getcwd()</code></pre><p>更详细的 path 文档 <a href="https://docs.python.org/2/library/os.path.html" target="_blank" rel="noopener">https://docs.python.org/2/library/os.path.html</a></p><h2 id="其它相关路径"><a href="#其它相关路径" class="headerlink" title="其它相关路径"></a>其它相关路径</h2><pre><code>#当前文件路径print(os.path.realpath(__file__))#当前文件所在的目录，即父路径print(os.path.split(os.path.realpath(__file__))[0])#找到父路径下的其他文件，即同级的其他文件print(os.path.join(proDir,&quot;config.ini&quot;))</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 文件路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python PIL 生成图片验证码</title>
      <link href="/posts/2019-12-28-63494.html"/>
      <url>/posts/2019-12-28-63494.html</url>
      
        <content type="html"><![CDATA[<p>下面是一个用python PIL 生成验证码的函数。</p><a id="more"></a><p>过程是：创建一张有底色的图片、在背景上添加杂色、写上特定文字、保存图片</p><pre><code># -*- coding: utf-8 -*-import randomimport Imageimport ImageFontimport ImageDrawimport ImageFilterdef gen_captcha(text, fnt, fnt_sz, file_name, fmt=&#39;JPEG&#39;):    # 随机生成背景色    fgcolor = random.randint(0,0xffff00)    bgcolor = fgcolor ^ 0xffffff    # 生成文字    font = ImageFont.truetype(fnt,fnt_sz)    dim = font.getsize(text)    im = Image.new(&#39;RGB&#39;, (dim[0]+5,dim[1]+5), bgcolor)    d = ImageDraw.Draw(im)    x, y = im.size    r = random.randint    # 给背景添加杂色    for num in range(100):        d.rectangle((r(0,x), r(0,y), r(0,x), r(0,y)), fill=r(0, 0xffffff))    # 添加文字    d.text((3,3), text, font=font, fill=fgcolor)    im = im.filter(ImageFilter.EDGE_ENHANCE_MORE)    im.save(file_name, format=fmt)def gen_random_word(wordLen=6):    allowedChars = &quot;abcdefghijklmnopqrstuvwzyzABCDEFGHIJKLMNOPQRSTUVWZYZ0123456789&quot;    word = &quot;&quot;    for i in range(0, wordLen):        word = word + allowedChars[random.randint(0,0xffffff) % len(allowedChars)]    return wordif __name__ == &#39;__main__&#39;:    word = gen_random_word()    print word    gen_captcha(word.strip(), &#39;porkys.ttf&#39;, 65, &quot;test.jpg&quot;)</code></pre><h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><p>一般情况不会要求填写验证码，避免影响用户体验。在特定情况下，如当用户登录密码出错N 次后，当用户频繁发贴时。</p><p>可对验证码作更复杂的变换，当用户输入验证码出错次数为N 时，增加其难度，如增加字符集、变化字体等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> PIL </tag>
            
            <tag> 验证码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用python 正确计算大文件md5 值</title>
      <link href="/posts/2019-12-28-4278.html"/>
      <url>/posts/2019-12-28-4278.html</url>
      
        <content type="html"><![CDATA[<p>python 计算文件的md5值很方便，但如果只是简单的把文件都入到内存中，大文件会导致问题，一般采用切片的方式分段计算，下面的几个函数可以很好的解决这个问题。</p><a id="more"></a><h2 id="使用-hashlib"><a href="#使用-hashlib" class="headerlink" title="使用 hashlib"></a>使用 hashlib</h2><pre><code>import hashlibdef md5_for_file(f, block_size=2**20):    md5 = hashlib.md5()    while True:        data = f.read(block_size)        if not data:            break        md5.update(data)    return md5.digest()def md5sum(filename, blocksize=65536):    hash = hashlib.md5()    with open(filename, &quot;r+b&quot;) as f:        for block in iter(lambda: f.read(blocksize), &quot;&quot;):            hash.update(block)    return hash.hexdigest()</code></pre><h2 id="使用-Crypto-Hash"><a href="#使用-Crypto-Hash" class="headerlink" title="使用 Crypto.Hash"></a>使用 Crypto.Hash</h2><pre><code>import osfrom Crypto.Hash import MD5def get_file_checksum(filename):    h = MD5.new()    chunk_size = 8192    with open(filename, &#39;rb&#39;) as f:        while True:            chunk = f.read(chunk_size)            if len(chunk) == 0:                break            h.update(chunk)    return h.hexdigest()</code></pre><p>上面三个函数都能正确计算大文件md5 值</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> md5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/2019-12-24-16107.html"/>
      <url>/posts/2019-12-24-16107.html</url>
      
        <content type="html"><![CDATA[<p>基于Hexo编写的轻巧简洁小清新博客。</p><a id="more"></a><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> install </tag>
            
            <tag> nodeJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python form-data post上传数据简便方法</title>
      <link href="/posts/2019-12-24-54485.html"/>
      <url>/posts/2019-12-24-54485.html</url>
      
        <content type="html"><![CDATA[<p>有时要用到 form-data 这种形式post 上传文件到服务器，下面介绍使用python 实现的简便方法。</p><a id="more"></a><p><img src="/images/posts/python-formdata-post.jpg" alt="python-formdata-post"></p><h2 id="方法一，使用-urllib2-自己打包"><a href="#方法一，使用-urllib2-自己打包" class="headerlink" title="方法一，使用 urllib2 自己打包"></a>方法一，使用 urllib2 自己打包</h2><p>自己封装form-data 也很方便</p><pre><code>def test():    #boundary只要是随机不同的就行    boundary = &#39;----------%s&#39; % hex(int(time.time() * 1000))    data = []    data.append(&#39;--%s&#39; % boundary)    fr=open(r&#39;test2.jpg&#39;,&#39;rb&#39;)    data.append(&#39;Content-Disposition: form-data; name=&quot;%s&quot;; filename=&quot;new_test2.jpg&quot;&#39; % &#39;file&#39;)    data.append(&#39;Content-Type: %s\r\n&#39; % &#39;image/jpeg&#39;)    data.append(fr.read())    fr.close()    data.append(&#39;--%s--\r\n&#39; % boundary)    #http_url=&#39;http://remotserver.com/page.php&#39;    http_url = &#39;http://xxx/v1/upload&#39;    http_body=&#39;\r\n&#39;.join(data)    try:        #buld http request        req=urllib2.Request(http_url, data=http_body)        #header        req.add_header(&#39;Content-Type&#39;, &#39;multipart/form-data; boundary=%s&#39; % boundary)#最重要的一行        #post data to server        resp = urllib2.urlopen(req, timeout=5)        #get response        qrcont=resp.read()        print qrcont    except Exception,e:        print &#39;http error&#39;</code></pre><h2 id="方法二，使用request"><a href="#方法二，使用request" class="headerlink" title="方法二，使用request"></a>方法二，使用request</h2><p>更简洁</p><pre><code>import requestsurl = &#39;xxx&#39;files={&#39;file&#39;:(&#39;newname.jpg&#39;,open(&#39;localname.jpg&#39;,&#39;rb&#39;),&#39;image/jpeg&#39;)}rsp=requests.post(url,files=files)print(rsp.request.text)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> form </tag>
            
            <tag> data </tag>
            
            <tag> post </tag>
            
            <tag> 上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用SSH 密钥登录VPS</title>
      <link href="/posts/2019-12-24-16726.html"/>
      <url>/posts/2019-12-24-16726.html</url>
      
        <content type="html"><![CDATA[<p>以前没有在VPS 上部署重要的东西，设置一个稍复杂的密码就可以。下面对记录一下VPS 禁止用户名+密码登录，仅使用密钥登录的过程。</p><a id="more"></a><p><img src="/images/posts/SSH%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95VPS.jpg" alt="SSH密钥登录VPS"></p><h2 id="生成SSH-公钥"><a href="#生成SSH-公钥" class="headerlink" title="生成SSH 公钥"></a>生成SSH 公钥</h2><p>确认是否已经有一个公钥，即检查<code>.ssh</code>文件夹，以及文件夹中是否存在<code>id_rsa</code> 和 <code>id_rsa.pub</code>文件，有.pub后缀的文件就是公钥，另一个文件则是密钥。如果不存在，或者干脆连<code>.ssh</code>文件夹都没有，可以进行创建。如果存在，就直接把<code>id_rsa.pub</code>内容输出，粘贴的服务器的相关文件。</p><pre><code>$ cd ~/.ssh$ ls</code></pre><p>可以用<code>ssh-keygen</code>来创建<br>默认公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空。</p><h2 id="更改VPS-sshd-配置"><a href="#更改VPS-sshd-配置" class="headerlink" title="更改VPS sshd 配置"></a>更改VPS sshd 配置</h2><p>编辑sshd 配置文件 <code>/etc/ssh/sshd_config</code><br>找到并修改为下面的样子：</p><pre><code>RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile      %h/.ssh/authorized_keysPasswordAuthentication no</code></pre><h3 id="添加公钥"><a href="#添加公钥" class="headerlink" title="添加公钥"></a>添加公钥</h3><p>打开文件<code>~/.ssh/authorized_keys</code>， 把本地的<code>id_rsa.pub</code> 内容粘贴到里面，保存退出</p><h3 id="重启sshd-服务"><a href="#重启sshd-服务" class="headerlink" title="重启sshd 服务"></a>重启sshd 服务</h3><pre><code>service sshd restart</code></pre><h2 id="其它安全措施"><a href="#其它安全措施" class="headerlink" title="其它安全措施"></a>其它安全措施</h2><p>上面所说的登录方式只是最基本的安全措施，还有比如更改ssh 默认端口、禁止root用户登录、使用denyhosts、启用iptables限制等等。</p><p>查看尝试暴力破解机器密码的人</p><pre><code>grep &quot;Failed password for root&quot; /var/log/auth.log | awk &#39;{print $11}&#39; | sort | uniq -c | sort -nr | more</code></pre><h2 id="查看成功登录信息"><a href="#查看成功登录信息" class="headerlink" title="查看成功登录信息"></a>查看成功登录信息</h2><pre><code>查看当前登录用户信息who命令：who缺省输出包括用户名、终端类型、登陆日期以及远程主机。who /var/log/wtmplastlast 用户名last -t 20181206160404显示这个时间戳之前的登陆历史</code></pre><h2 id="客户端密钥备份"><a href="#客户端密钥备份" class="headerlink" title="客户端密钥备份"></a>客户端密钥备份</h2><p>如果电脑重装了，就很难登录服务器，可以备份密钥，直接复制<code>id_rsa</code>、<code>id_rsa.pub</code>两个文件。当电脑重装或者想在其他电脑上登录主机，直接把这两个文件复制到 <code>~/.ssh/</code> 目录下就行。<br>如果使用备份的<code>id_rsa</code> 文件出现下面的错误提示</p><pre><code>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0644 for &#39;id_rsa&#39; are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored.</code></pre><p>可以用更改文件属性的方法来解决</p><pre><code>chmod 0600 id_rsa</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> VPS </tag>
            
            <tag> SSH </tag>
            
            <tag> 密钥 </tag>
            
            <tag> 登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenSSL 生成自签名证书备忘</title>
      <link href="/posts/2019-12-24-63828.html"/>
      <url>/posts/2019-12-24-63828.html</url>
      
        <content type="html"><![CDATA[<p>用 OpenSSL 生成自签名证书的步骤：</p><a id="more"></a><p><img src="/images/posts/OpenSSL.jpg" alt="OpenSSL"></p><ul><li>创建Key； </li><li>创建签名请求；</li><li>将Key的口令移除；</li><li>用Key签名证书。<br>为HTTPS准备的证书需要注意，创建的签名请求的CN必须与域名完全一致，否则无法通过浏览器验证。<br>具体命令如下，把域名改为自己的域名：<pre><code>openssl genrsa -des3 -out $DOMAIN.key 1024openssl req -new -subj &quot;/C=US/ST=Mars/L=iTranswarp/O=iTranswarp/OU=iTranswarp/CN=$DOMAIN&quot; -key $DOMAIN.key -out $DOMAIN.csrmv $DOMAIN.key $DOMAIN.origin.keyopenssl rsa -in $DOMAIN.origin.key -out $DOMAIN.keyopenssl x509 -req -days 3650 -in $DOMAIN.csr -signkey $DOMAIN.key -out $DOMAIN.crt</code></pre>有时需要下面两个文件名更加方便识别：<pre><code>cp $DOMAIN.crt cert.pemcp $DOMAIN.key key.pem</code></pre>nginx 配置：<pre><code>ssl_certificate     $DOMAIN.crt;ssl_certificate_key $DOMAIN.key;</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> OpenSSL </tag>
            
            <tag> 证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac pip2 与 pip3 共存</title>
      <link href="/posts/2019-12-24-6349.html"/>
      <url>/posts/2019-12-24-6349.html</url>
      
        <content type="html"><![CDATA[<p>Mac 上的 pip2 与 pip3 共存笔记</p><a id="more"></a><p><img src="/images/posts/pip2-pip3.jpg" alt="pip2-pip3"><br>这里不想启用<code>pyenv</code><br>下载 <code>get-pip.py</code></p><pre><code>curl -O https://bootstrap.pypa.io/get-pip.py</code></pre><p>首先安装pip （pip2）</p><pre><code>sudo python2 get-pip.py</code></pre><p>再安装 <code>pip3</code></p><pre><code>sudo python3 get-pip.py</code></pre><p>测试：</p><pre><code>$ pip -Vpip 18.1 from /Library/Python/2.7/site-packages/pip-18.1-py2.7.egg/pip (python 2.7)$ pip2 -Vpip 18.1 from /Library/Python/2.7/site-packages/pip-18.1-py2.7.egg/pip (python 2.7)$ pip3 -Vpip 18.1 from /usr/local/lib/python3.6/site-packages/pip (python 3.6)</code></pre><p>如果失败就动用 <code>easy_install</code> 来安装：</p><pre><code>sudo easy_install pip</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> pip2 </tag>
            
            <tag> pip3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenWrt 国内源</title>
      <link href="/posts/2019-12-24-11985.html"/>
      <url>/posts/2019-12-24-11985.html</url>
      
        <content type="html"><![CDATA[<p>国内可用 OpenWrt 镜像</p><a id="more"></a><ul><li><a href="https://mirrors.ustc.edu.cn/lede/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/lede/</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/openwrt/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/openwrt/</a> 只更新到 chaos_calmer/15.05.1/</li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/lede/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/lede/</a> openwrt 最新版</li></ul><p>官方网站推荐的其他镜像</p><ul><li><a href="https://openwrt.org/downloads#mirrors" target="_blank" rel="noopener">https://openwrt.org/downloads#mirrors</a></li></ul><p>修改文件 <code>/etc/opkg/distfeeds.conf</code><br><img src="/images/posts/OpenWrt.png" alt="OpenWrt"></p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenWrt </tag>
            
            <tag> 国内 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开启BBR 加速小VPS访问速度</title>
      <link href="/posts/2019-12-24-27787.html"/>
      <url>/posts/2019-12-24-27787.html</url>
      
        <content type="html"><![CDATA[<p>TCP BBR 是 Google 开发的新的拥塞控制算法，据说是用在 YouTube 上，后来开源并且已经集成到 Linux 4.9-rc8 之后版本的内核中。它可以极大提高网络速度，大大降低延迟。</p><a id="more"></a><p>加速效果如下图所示：<br><img src="/images/posts/open-BBR.gif" alt="open-BBR"><br>如果你的 VPS 使用的是 OpenVZ 的虚拟技术，你是不能使用 BBR 的。并且系统要求在 CentOS 6+，Debian 7+，Ubuntu 12+。<br>对于4.9+的内核，默认编译了 TCP BBR 的内容，可以直接通过参数开启<br>uname -r 看看是不是内核 &gt;= 4.9<br>执行 <code>lsmod | grep bbr</code> ，如果结果中没有 <code>tcp_bbr</code> 的话就先执行</p><pre><code>modprobe tcp_bbrecho &quot;tcp_bbr&quot; &gt;&gt; /etc/modules-load.d/modules.conf</code></pre><p>执行</p><pre><code>echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.confecho &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</code></pre><p>保存生效</p><pre><code>sysctl -p</code></pre><p>执行</p><pre><code>sysctl net.ipv4.tcp_available_congestion_controlsysctl net.ipv4.tcp_congestion_control</code></pre><p>如果结果都有bbr, 则证明你的内核已开启bbr</p><p>看到有 tcp_bbr 模块即说明bbr已启动</p><p>再实行 <code>lsmod | grep bbr</code>，显示以下即启动成功：</p><pre><code>lsmod | grep bbrtcp_bbr                20480  14</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> BBR </tag>
            
            <tag> 开启 </tag>
            
            <tag> 访问速度 </tag>
            
            <tag> VPS </tag>
            
            <tag> 加速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Openwrt 路由上开启BBR</title>
      <link href="/posts/2019-12-24-46437.html"/>
      <url>/posts/2019-12-24-46437.html</url>
      
        <content type="html"><![CDATA[<p>BBR 是一种协议算法，在 Openwrt 路由上启用 BBR 还是有一定作用的。 Openwrt 18.* 后都自带模块 <code>kmod-tcp-bbr</code> 安装就可以。</p><a id="more"></a><p><img src="/images/posts/Openwrt-BBR.jpg" alt="Openwrt-BBR"><br>看内核版本</p><pre><code>root@OpenWrt:~# uname -r4.9.184</code></pre><p>安装 <code>kmod-tcp-bbr</code></p><pre><code>opkg updateopkg install kmod-tcp-bbr</code></pre><p>会安装相关的 ipk</p><pre><code>Configuring kmod-sched-core.Configuring kmod-sched.Configuring kmod-tcp-bbr.</code></pre><p>查看相关情况</p><pre><code>root@OpenWrt:~# sysctl net.ipv4.tcp_congestion_controlnet.ipv4.tcp_congestion_control = cubicroot@OpenWrt:~# sysctl net.ipv4.tcp_available_congestion_controlnet.ipv4.tcp_available_congestion_control = cubic reno bbrroot@OpenWrt:~# sysctl net.core.default_qdiscnet.core.default_qdisc = fq_codelroot@OpenWrt:~# lsmod | grep bbrtcp_bbr                 4832  0root@OpenWrt:~# cat /etc/sysctl.conf# Defaults are configured in /etc/sysctl.d/* and can be customized in this fileroot@OpenWrt:~# ls -l /etc/sysctl.d/-rw-r--r--    1 root     root           675 Jun 27 12:18 10-default.conf-rw-r--r--    1 root     root           379 Jun 27 12:18 11-nf-conntrack.conf-rw-r--r--    1 root     root           184 Jun 27 12:18 12-tcp-bbr.confroot@OpenWrt:~# cat /etc/sysctl.d/12-tcp-bbr.conf# Do not edit, changes to this file will be lost on upgrades# /etc/sysctl.conf can be used to customize sysctl settingsnet.ipv4.tcp_congestion_control=bbrnet.core.default_qdisc=fqroot@OpenWrt:~# sysctl -proot@OpenWrt:~# lsmod | grep bbrtcp_bbr                 4832  0</code></pre><p>还没生效，重启路由后再看看</p><pre><code>root@OpenWrt:~# lsmod | grep bbrtcp_bbr                 4832 21root@OpenWrt:~# sysctl net.ipv4.tcp_congestion_controlnet.ipv4.tcp_congestion_control = bbr</code></pre><p>BBR 加速生效了！</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenWrt </tag>
            
            <tag> BBR </tag>
            
            <tag> 路由 </tag>
            
            <tag> 开启 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim 与中文输入法</title>
      <link href="/posts/2019-12-21-21047.html"/>
      <url>/posts/2019-12-21-21047.html</url>
      
        <content type="html"><![CDATA[<p>我最后还是放弃把 Vim 作为主要编辑器来输入中文了，整体使用下来 mental model 的 cost 太重了。<a id="more"></a>记笔记时用用中文呀或者改改博客时偶尔用一下还<br>蛮去，这个时候这个功能至少能帮助你 Esc 之后不煞笔，所以也不算完全没有价值吧……</p><hr><p>我相信很多中文世界的 Vimer 都遇到过这个烦恼，在 vim 的 insert 模式时可能突然想输个中文，输完之后会本能的直接 <code>esc</code> 接 normal 模式操作，结果发现<br>跳出来的是中文输入法……对于 vscode，我一般会在几次错误之后被逼到退出 vscode vim 模式，而对于终端中用的 neovim，就只能尽量不输入中文了。</p><p>为了满足我 1% 用 vim 输入中文的场景（比如写博客），我还是想看看有没有什么解决方案，Google 出来的解决方案基本是：<em>在退出 insert 模式时记住当时的<br>输入法，并自动切换到默认输入法（一般是英文）给 normal 模式用，并且在下一次进入 insert 模式时再切换回来。</em></p><p>原生 vim 的话，可以使用 <a href="https://github.com/ybian/smartim" target="_blank" rel="noopener">smartim</a> 插件，原理是调用 <a href="https://github.com/daipeihust/im-select" target="_blank" rel="noopener">im-select</a> 这个 CLI 工具来切换输入法。</p><p>对于 VSCode-vim 的话，smartim 的移植也在近期的 PR 中被 merge 到了插件里，<a href="https://github.com/VSCodeVim/Vim#use-im-select" target="_blank" rel="noopener">详情见文档的这部分配置</a>，需要指定一下默认输入法和 im-select 的 binary 路径就好。</p><hr><p>不过实话说，在 vim 中编辑中文的效率和体验和英文比都是大打折扣的。因为中文分词难度太高，不像英文可以简单依靠一个 <code>split &quot; &quot;</code> 搞定。所以其实无论 vim（<code>w</code>ord，<code>b</code>egin，<code>e</code>nd），emacs 还是操作系统自带的（比如 macOS 中的 <code>alt + 箭头</code>） 「按词移动」功能对于中文都仅仅是跳转到下一个空格处而已&gt;，对于中文来说基本就是下一句了……其他常用操作诸如 <code>f</code>，<code>/</code>, <code>r</code>eplace, <code>t</code>ill 也都无法很好的工作，基本只能靠 <code>hjkl</code> 爬行……</p><p>不过也算聊胜于无吧，由于我的主力外置键盘是 HHKB，能用 vim 操作的一个子集（<code>hjkl</code>, <code>o</code>, <code>A</code>, <code>I</code>, <code>v</code> etc.）可能也比按住 <code>Fn</code> 的方向键好用……</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vim </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown插入图片、视频和公式</title>
      <link href="/posts/2019-12-20-33346.html"/>
      <url>/posts/2019-12-20-33346.html</url>
      
        <content type="html"><![CDATA[<p>记录一些常用的Markdown插入图片和视频方法</p><a id="more"></a><h2 id="1-Markdown-插入图片的几种方法"><a href="#1-Markdown-插入图片的几种方法" class="headerlink" title="1. Markdown 插入图片的几种方法"></a>1. Markdown 插入图片的几种方法</h2><h3 id="1-1-原-markdown-语法"><a href="#1-1-原-markdown-语法" class="headerlink" title="1.1 原 markdown 语法"></a>1.1 原 markdown 语法</h3><pre><code class="markdown">![这是图片描述](这是图片链接)</code></pre><h3 id="1-2-html-语法"><a href="#1-2-html-语法" class="headerlink" title="1.2 html 语法"></a>1.2 html 语法</h3><pre><code class="html">&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shw2018/cdn/master/blog_files/img/PicGo-Github-PicBed/2.png&quot; &gt;&lt;/p&gt;</code></pre><h2 id="2-插入音乐-以网易云音乐为例"><a href="#2-插入音乐-以网易云音乐为例" class="headerlink" title="2. 插入音乐,以网易云音乐为例"></a>2. 插入音乐,以网易云音乐为例</h2><p>例1：</p><pre><code class="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=450 src=&quot;//music.163.com/outchain/player?type=0&amp;id=2737308121&amp;auto=1&amp;height=430&quot;&gt;&lt;/iframe&gt;</code></pre><p>效果：</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=450 src="//music.163.com/outchain/player?type=0&id=2737308121&auto=1&height=430"></iframe><h2 id="3-几种文章内视频插入的方法"><a href="#3-几种文章内视频插入的方法" class="headerlink" title="3. 几种文章内视频插入的方法"></a>3. 几种文章内视频插入的方法</h2><p>例1：</p><pre><code class="html">&lt;video width=&quot;100%&quot; height=100% src=&quot;https://yanghexo.cn-bj.ufileos.com/github.mp4&quot; controls=&quot;controls&quot; poster=&quot;https://yanghexo.cn-bj.ufileos.com/github.jpg&quot; preload=&quot;auto&quot;&gt; &lt;/video&gt;</code></pre><p>效果：</p><p><video width="100%" height=100% src="https://yanghexo.cn-bj.ufileos.com/github.mp4" controls="controls" poster="https://yanghexo.cn-bj.ufileos.com/github.jpg" preload="auto"> </video></p><p>例二：<br>需要先装一个插件：<code>npm install hexo-tag-dplayer --save</code></p><pre><code>{% dplayer "url=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.mp4" "addition=https://dplayer.daoapp.io/bilibili?aid=4157142" "api=https://api.prprpr.me/dplayer/" "pic=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.jpg" "id=9E2E3368B56CDBB4" "loop=yes" "theme=#FADFA3" "autoplay=false" "token=tokendemo" %} {% dplayer 'url=some.mp4' "id=someid" "api=https://api.prprpr.me/dplayer/" "addition=/some.json" 'code=player.on("loadstart",function(){console.log("loadstart")})' "autoplay" %}</code></pre><p>效果：</p><p>例三：</p><p>iframe内嵌哔哩哔哩视频播放</p><pre><code class="html">&lt;iframe width=&quot;100%&quot; height=&quot;100%&quot; src=&quot;//player.bilibili.com/player.html?aid=52012946&amp;cid=91055960&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;</code></pre><iframe width="100%" height="500px" src="//player.bilibili.com/player.html?aid=52012946&cid=91055960&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><hr><p>参数说明：</p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>autoplay</td><td><em>autoplay</em></td><td>如果出现该属性，则视频在就绪后马上播放。</td></tr><tr><td>controls</td><td><em>controls</em></td><td>如果出现该属性，则向用户显示控件，比如播放按钮。</td></tr><tr><td>width</td><td><em>pixels</em></td><td>设置视频播放器的宽度。</td></tr><tr><td>height</td><td><em>pixels</em></td><td>设置视频播放器的高度。</td></tr><tr><td>loop</td><td><em>loop</em></td><td>如果出现该属性，则当媒介文件完成播放后再次开始播放。</td></tr><tr><td>multed</td><td>_multed</td><td>如果出现该属性，视频的音频输出为静音。</td></tr><tr><td>poster</td><td><em>URL</em></td><td>规定视频正在下载时显示的图像，直到用户点击播放按钮。</td></tr><tr><td>srv</td><td><em>URL</em></td><td>要播放的视频的 URL。</td></tr><tr><td>preload</td><td><em>auto metadata none</em></td><td>如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td></tr></tbody></table><ul><li>例子：</li></ul><pre><code>$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，行内公式示例} $</code></pre><p>显示：<br>$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，行内公式示例} $</p><ul><li>例子：</li></ul><pre><code class="mathematical">$$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，独立公式示例} $$</code></pre><p>显示：<br>$$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，独立公式示例<br>} $$</p><ul><li>例子：</li></ul><pre><code class="mathematical">$$ f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right) $$</code></pre><p>显示：<br>$$ f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right) $$</p><ul><li>例子：</li></ul><pre><code class="mathematical">$$\frac{a-1}{b-1} \quad and \quad {a+1\over b+1}$$</code></pre><p>显示：<br>$$\frac{a-1}{b-1} \quad and \quad {a+1\over b+1}$$</p><p>例子：</p><pre><code class="mathematical">$$f(x_1,x_2,\underbrace{\ldots}_{\rm ldots} ,x_n) = x_1^2 + x_2^2 + \underbrace{\cdots}_{\rm cdots} + x_n^2$$</code></pre><p>显示：<br>$$f(x_1,x_2,\underbrace{\ldots}<em>{\rm ldots} ,x_n) = x_1^2 + x_2^2 + \underbrace{\cdots}</em>{\rm cdots} + x_n^2$$</p><p>例子：</p><pre><code class="mathematical">$$d = \sqrt{(x_2-x_1)^2+(y_2-y_1)^2},|X|=\sqrt{x_2^2+y_2^2}.$$</code></pre><p>显示：</p><p>$$<br>d = \sqrt{(x_2-x_1)^2+(y_2-y_1)^2},|X|=\sqrt{x_2^2+y_2^2}.<br>$$</p><p>例子：</p><pre><code class="mathematical">$$d = \sqrt{(x_2-x_1)^2+(y_2-y_1)^2+(z_2-z_1)^2},|X|=\sqrt{x_2^2+y_2^2+z_2^2}.$$</code></pre><p>显示：<br>$$<br>d = \sqrt{(x_2-x_1)^2+(y_2-y_1)^2+(z_2-z_1)^2},|X|=\sqrt{x_2^2+y_2^2+z_2^2}.<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 写作 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
