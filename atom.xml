<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeeZC&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.leezc.cn/"/>
  <updated>2020-01-08T10:38:34.000Z</updated>
  <id>https://blog.leezc.cn/</id>
  
  <author>
    <name>leezc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python实现加密方法合集</title>
    <link href="https://blog.leezc.cn/posts/2020-01-08-6575.html"/>
    <id>https://blog.leezc.cn/posts/2020-01-08-6575.html</id>
    <published>2020-01-08T10:38:34.000Z</published>
    <updated>2020-01-08T10:38:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们所说的加密方式，都是对二进制编码的格式进行加密的，对应到Python中，则是我们的Bytes。所以当我们在Python中进行加密操作的时候，要确保我们操作的是Bytes，否则就会报错。</p><a id="more"></a><p><img src="/images/posts/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95.jpg" alt="对称加密算法"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>明文：明文是指没有经过加密的数据。一般而言，明文都是等待传输的数据。由于没有经过加密，明文很容易被识别与破解，因此在传输明文之前必须进行加密处理。</li><li>密文：密文只是明文经过某种加密算法而得到的数据，通常密文的形式复杂难以识别及理解。</li><li>密钥：密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。</li><li>对称加密：通信双方同时掌握一个密钥，加密解密都是由一个密钥完成的（即加密密钥等于解密密钥，加解密密钥可以相互推倒出来）。双方通信前共同拟定一个密钥，不对第三方公开。</li><li>分组加密：分组密码是将明文分成固定长度的组，每一组都采用同一密钥和算法进行加密，输出也是固定长度的密文。</li></ul><h2 id="加密算法分类"><a href="#加密算法分类" class="headerlink" title="加密算法分类"></a>加密算法分类</h2><h3 id="对称加密算法："><a href="#对称加密算法：" class="headerlink" title="对称加密算法："></a>对称加密算法：</h3><p>对称加密采用了对称密码编码技术，它的特点是文件加密和解密使用相同的密钥</p><p>发送方和接收方需要持有同一把密钥，发送消息和接收消息均使用该密钥。</p><p>相对于非对称加密，对称加密具有更高的加解密速度，但双方都需要事先知道密钥，密钥在传输过程中可能会被窃取，因此安全性没有非对称加密高。</p><p>常见的对称加密算法：DES，AES，3DES等等</p><h3 id="非对称加密算法："><a href="#非对称加密算法：" class="headerlink" title="非对称加密算法："></a>非对称加密算法：</h3><p>文件加密需要公开密钥（publickey）和私有密钥（privatekey）。</p><p>接收方在发送消息前需要事先生成公钥和私钥，然后将公钥发送给发送方。发送放收到公钥后，将待发送数据用公钥加密，发送给接收方。接收到收到数据后，用私钥解密。</p><p>在这个过程中，公钥负责加密，私钥负责解密，数据在传输过程中即使被截获，攻击者由于没有私钥，因此也无法破解。</p><p>非对称加密算法的加解密速度低于对称加密算法，但是安全性更高。</p><p>非对称加密算法：RSA、DSA、ECC等算法</p><h3 id="消息摘要算法："><a href="#消息摘要算法：" class="headerlink" title="消息摘要算法："></a>消息摘要算法：</h3><p>消息摘要算法可以验证信息是否被篡改。</p><p>在数据发送前，首先使用消息摘要算法生成该数据的签名，然后签名和数据一同发送给接收者。</p><p>接收者收到数据后，对收到的数据采用消息摘要算法获得签名，最后比较签名是否一致，以此来判断数据在传输过程中是否发生修改。</p><h2 id="Python实现加密方法合集"><a href="#Python实现加密方法合集" class="headerlink" title="Python实现加密方法合集"></a>Python实现加密方法合集</h2><pre><code class="python"># -*- coding：utf-8 -*-import base64import rsafrom Crypto.Cipher import AESfrom Crypto.PublicKey import RSAfrom pyDes import des, CBC, PAD_PKCS5from Crypto.Cipher import DES3import hashlibimport hmacclass USE_AES:    &quot;&quot;&quot;    AES    除了MODE_SIV模式key长度为：32, 48, or 64,    其余key长度为16, 24 or 32    详细见AES内部文档    CBC模式传入iv参数    本例使用常用的ECB模式    &quot;&quot;&quot;    def __init__(self, key):        if len(key) &gt; 32:            key = key[:32]        self.key = self.to_16(key)    def to_16(self, key):        &quot;&quot;&quot;        转为16倍数的bytes数据        :param key:        :return:        &quot;&quot;&quot;        key = bytes(key, encoding=&quot;utf8&quot;)        while len(key) % 16 != 0:            key += b&#39;\0&#39;        return key  # 返回bytes    def aes(self):        return AES.new(self.key, AES.MODE_ECB) # 初始化加密器    def encrypt(self, text):        aes = self.aes()        return str(base64.encodebytes(aes.encrypt(self.to_16(text))),                   encoding=&#39;utf8&#39;).replace(&#39;\n&#39;, &#39;&#39;)  # 加密    def decodebytes(self, text):        aes = self.aes()        return str(aes.decrypt(base64.decodebytes(bytes(            text, encoding=&#39;utf8&#39;))).rstrip(b&#39;\0&#39;).decode(&quot;utf8&quot;))  # 解密class USE_RSA:    &quot;&quot;&quot;    生成密钥可保存.pem格式文件    1024位的证书，加密时最大支持117个字节，解密时为128；    2048位的证书，加密时最大支持245个字节，解密时为256。    加密大文件时需要先用AES或者DES加密，再用RSA加密密钥，详细见文档    文档:https://stuvel.eu/files/python-rsa-doc/usage.html#generating-keys    &quot;&quot;&quot;    def __init__(self, number=1024):        &quot;&quot;&quot;        :param number: 公钥、私钥        &quot;&quot;&quot;        self.pubkey, self.privkey = rsa.newkeys(number)    def rsaEncrypt(self, text):        &quot;&quot;&quot;        :param test: str        :return: bytes        &quot;&quot;&quot;        content = text.encode(&#39;utf-8&#39;)        crypto = rsa.encrypt(content, self.pubkey)        return crypto    def rsaDecrypt(self, text):        &quot;&quot;&quot;        :param text:bytes         :return: str        &quot;&quot;&quot;        content = rsa.decrypt(text, self.privkey)        con = content.decode(&#39;utf-8&#39;)        return con    def savePem(self, path_name, text):        &quot;&quot;&quot;        :param path_name: 保存路径        :param text: str        :return:bytes        &quot;&quot;&quot;        if &quot;PEM&quot; in path_name.upper():            path_name = path_name[:-4]        with open(&#39;{}.pem&#39;.format(path_name), &#39;bw&#39;) as f:            f.write(text.save_pkcs1())    def readPem(self, path_name, key_type):        &quot;&quot;&quot;        :param path_name: 密钥文件        :param key_type:类型         :return:         &quot;&quot;&quot;        if &#39;pubkey&#39; in key_type:            self.pubkey = rsa.PublicKey.load_pkcs1(path_name)        else:            self.privkey = rsa.PublicKey.load_pkcs1(path_name)        return True    def sign(self, message, priv_key=None, hash_method=&#39;SHA-1&#39;):        &quot;&quot;&quot;        生成明文的哈希签名以便还原后对照        :param message: str        :param priv_key:        :param hash_method: 哈希的模式        :return:        &quot;&quot;&quot;        if None == priv_key:            priv_key = self.privkey        return rsa.sign(message.encode(), priv_key, hash_method)    def checkSign(self, mess, result, pubkey=None):        &quot;&quot;&quot;        验证签名：传入解密后明文、签名、公钥，验证成功返回哈希方法，失败则报错        :param mess: str        :param result: bytes        :param pubkey:         :return: str        &quot;&quot;&quot;        if None == pubkey:            pubkey = self.privkey        try:            result = rsa.verify(mess, result, pubkey)            return result        except:            return Falseclass USE_DES:    &quot;&quot;&quot;    des(key,[mode], [IV], [pad], [pad mode])    key:必须正好8字节    mode（模式）：ECB、CBC    iv:CBC模式中必须提供长8字节    pad:填充字符    padmode:加密填充模式PAD_NORMAL or PAD_PKCS5    &quot;&quot;&quot;    def __init__(self, key, iv):        if not isinstance(key, bytes):            key = bytes(key, encoding=&quot;utf8&quot;)        if not isinstance(iv, bytes):            iv = bytes(iv, encoding=&quot;utf8&quot;)        self.key = key        self.iv = iv    def encrypt(self, text):        &quot;&quot;&quot;        DES 加密        :param text: 原始字符串        :return: 加密后字符串，bytes        &quot;&quot;&quot;        if not isinstance(text, bytes):            text = bytes(text, &quot;utf-8&quot;)        secret_key = self.key        iv = self.iv        k = des(secret_key, CBC, iv, pad=None, padmode=PAD_PKCS5)        en = k.encrypt(text, padmode=PAD_PKCS5)        return en    def descrypt(self, text):        &quot;&quot;&quot;        DES 解密        :param text: 加密后的字符串，bytes        :return:  解密后的字符串        &quot;&quot;&quot;        secret_key = self.key        iv = self.iv        k = des(secret_key, CBC, iv, pad=None, padmode=PAD_PKCS5)        de = k.decrypt(text, padmode=PAD_PKCS5)        return de.decode()class USE_DES3:    &quot;&quot;&quot;    new(key, mode, *args, **kwargs)    key:必须8bytes倍数介于16-24    mode：    iv:初始化向量适用于MODE_CBC、MODE_CFB、MODE_OFB、MODE_OPENPGP，4种模式        ``MODE_CBC``, ``MODE_CFB``, and ``MODE_OFB``长度为8bytes        ```MODE_OPENPGP```加密时8bytes解密时10bytes        未提供默认随机生成    nonce：仅在 ``MODE_EAX`` and ``MODE_CTR``模式中使用            ``MODE_EAX``建议16bytes            ``MODE_CTR``建议[0, 7]长度            未提供则随机生成    segment_size：分段大小，仅在 ``MODE_CFB``模式中使用，长度为8倍数，未指定则默认为8    mac_len： 适用``MODE_EAX``模式，身份验证标记的长度（字节），它不能超过8（默认值）    initial_value：适用```MODE_CTR```，计数器的初始值计数器块。默认为**0**。    &quot;&quot;&quot;    def __init__(self, key):        self.key = key        self.mode = DES3.MODE_ECB    def encrypt(self, text):        &quot;&quot;&quot;        传入明文        :param text:bytes类型，长度是KEY的倍数        :return:        &quot;&quot;&quot;        if not isinstance(text, bytes):            text = bytes(text, &#39;utf-8&#39;)        x = len(text) % 8        text = text+b&#39;\0&#39;*x        cryptor = DES3.new(self.key, self.mode)        ciphertext = cryptor.encrypt(text)        return ciphertext    def decrypt(self, text):        cryptor = DES3.new(self.key, self.mode)        plain_text = cryptor.decrypt(text)        st = str(plain_text.decode(&quot;utf-8&quot;)).rstrip(&#39;\0&#39;)        return stdef USE_MD5(test):    if not isinstance(test, bytes):        test = bytes(test, &#39;utf-8&#39;)    m = hashlib.md5()    m.update(test)    return m.hexdigest()def USE_HMAC(key, text):    if not isinstance(key, bytes):        key = bytes(key, &#39;utf-8&#39;)    if not isinstance(text, bytes):        text = bytes(text, &#39;utf-8&#39;)    h = hmac.new(key, text, digestmod=&#39;MD5&#39;)    return h.hexdigest()def USE_SHA(text):    if not isinstance(text, bytes):        text = bytes(text, &#39;utf-8&#39;)    sha = hashlib.sha1(text)    encrypts = sha.hexdigest()    return encryptsif __name__ == &#39;__main__&#39;:    aes_test = USE_AES(&quot;assssssssdfasasasasa&quot;)    a = aes_test.encrypt(&quot;测试&quot;)    b = aes_test.decodebytes(a)    rsa_test = USE_RSA()    a = rsa_test.rsaEncrypt(&quot;测试加密&quot;)    b = rsa_test.rsaDecrypt(a)    des_test = USE_DES(b&quot;12345678&quot;, b&quot;12345678&quot;)    a = des_test.encrypt(&quot;测试加密&quot;)    b = des_test.descrypt(a)    des3_test = USE_DES3(b&quot;123456789qazxswe&quot;)    a = des3_test.encrypt(&quot;测试加密&quot;)    b = des3_test.decrypt(a)    md5_test = USE_MD5(&quot;测试签名&quot;)    hmac_test = USE_HMAC(&quot;123456&quot;, &quot;测试&quot;)    sha_test = USE_SHA(&quot;测试加密&quot;)</code></pre><p>Github: <a href="https://github.com/dhfjcuff/R-A-M-D-D3-S-M-H/blob/master/RSA-AES-MD5-DES-DES3-MD5-SHA-HMAC.py" target="_blank" rel="noopener">https://github.com/dhfjcuff/R-A-M-D-D3-S-M-H/blob/master/RSA-AES-MD5-DES-DES3-MD5-SHA-HMAC.py</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们所说的加密方式，都是对二进制编码的格式进行加密的，对应到Python中，则是我们的Bytes。所以当我们在Python中进行加密操作的时候，要确保我们操作的是Bytes，否则就会报错。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://blog.leezc.cn/tags/python/"/>
    
      <category term="加密" scheme="https://blog.leezc.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="解密" scheme="https://blog.leezc.cn/tags/%E8%A7%A3%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>编写python脚本遍历文件夹并取指定后缀名文件</title>
    <link href="https://blog.leezc.cn/posts/2019-12-29-25741.html"/>
    <id>https://blog.leezc.cn/posts/2019-12-29-25741.html</id>
    <published>2019-12-29T00:07:06.000Z</published>
    <updated>2019-12-29T00:07:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>用python来遍历某个文件并获取指定后缀名文件</p><a id="more"></a><h2 id="python-实现函数代码"><a href="#python-实现函数代码" class="headerlink" title="python 实现函数代码"></a>python 实现函数代码</h2><pre><code>suffix = &#39;.php&#39;def get_file_list(_dir):    i = 0    for root, dirs, files in os.walk(_dir):        for f in files:            f_path = os.path.join(root, f)            if f_path.endswith(suffix):                f_path2 = &#39;/&#39; + f_path.replace(_dir, &#39;&#39;).strip(&#39;/&#39;)                print f_path2</code></pre><h2 id="walk-函数"><a href="#walk-函数" class="headerlink" title="walk 函数"></a>walk 函数</h2><pre><code>os.walk() 方法是一个简单易用的文件、目录遍历器，可以帮助我们高效的处理文件、目录方面的事情。用于通过在目录树中游走输出在目录中的文件名，向上或者向下。</code></pre><h3 id="walk-语法"><a href="#walk-语法" class="headerlink" title="walk 语法"></a>walk 语法</h3><pre><code>os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])</code></pre><h3 id="walk-参数"><a href="#walk-参数" class="headerlink" title="walk 参数"></a>walk 参数</h3><ul><li>top – 是你所要遍历的目录的地址, 返回的是一个三元组(root,dirs,files)。<ul><li>root 所指的是当前正在遍历的这个文件夹的本身的地址</li><li>dirs 是一个 list ，内容是该文件夹中所有的目录的名字(不包括子目录)</li><li>files 同样是 list , 内容是该文件夹中所有的文件(不包括子目录)</li></ul></li><li>topdown –可选，为 True，则优先遍历 top 目录，否则优先遍历 top 的子目录(默认为开启)。如果 topdown 参数为 True，walk 会遍历top文件夹，与top 文件夹中每一个子目录。</li><li>onerror – 可选，需要一个 callable 对象，当 walk 需要异常时，会调用。</li><li>followlinks – 可选，如果为 True，则会遍历目录下的快捷方式(linux 下是软连接 symbolic link )实际所指的目录(默认关闭)，如果为 False，则优先遍历 top 的子目录。</li></ul><h3 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h3><ul><li>root: 返回给定根目录，但是在有下级文件夹时候会改变</li><li>dir:如果有个文件夹下面存在文件，就是返回为空，这个时候root不为空，我们可以这种方法来处理数据。</li><li>flies:如果不为空，就为底层文件。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用python来遍历某个文件并获取指定后缀名文件&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://blog.leezc.cn/tags/python/"/>
    
      <category term="文件夹" scheme="https://blog.leezc.cn/tags/%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
    
      <category term="遍历" scheme="https://blog.leezc.cn/tags/%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>使用国内pip 源</title>
    <link href="https://blog.leezc.cn/posts/2019-12-28-9867.html"/>
    <id>https://blog.leezc.cn/posts/2019-12-28-9867.html</id>
    <published>2019-12-28T23:45:09.000Z</published>
    <updated>2019-12-28T23:45:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>有些服务器对外网络很坑，幸好国内有好多优秀的源镜像</p><a id="more"></a><p>优秀pip源推荐</p><pre><code>http://pypi.douban.com/  豆瓣http://pypi.hustunique.com/  华中理工大学http://pypi.sdutlinux.org/  山东理工大学http://pypi.mirrors.ustc.edu.cn/  中国科学技术大学</code></pre><pre><code>pip install web.py -i https://pypi.douban.com/simple</code></pre><p>~/.pip/pip.conf</p><pre><code>[global]index-url = https://pypi.douban.com/simple</code></pre><h2 id="清华大学开源镜像"><a href="#清华大学开源镜像" class="headerlink" title="清华大学开源镜像"></a>清华大学开源镜像</h2><p><a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/</a></p><p>临时使用</p><pre><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</code></pre><p>注意，<code>simple</code> 不能少, 是 <code>https</code> 而不是 <code>http</code></p><p>设为默认 升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置：</p><pre><code>pip install pip -Upip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有些服务器对外网络很坑，幸好国内有好多优秀的源镜像&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://blog.leezc.cn/tags/python/"/>
    
      <category term="pip" scheme="https://blog.leezc.cn/tags/pip/"/>
    
      <category term="国内源" scheme="https://blog.leezc.cn/tags/%E5%9B%BD%E5%86%85%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>python 用base64 对图片文件的编码和解码处理</title>
    <link href="https://blog.leezc.cn/posts/2019-12-28-35102.html"/>
    <id>https://blog.leezc.cn/posts/2019-12-28-35102.html</id>
    <published>2019-12-28T22:41:23.000Z</published>
    <updated>2019-12-28T22:41:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>用base64 对图片文件的编码和解码处理</p><a id="more"></a><pre><code>import base64def convert(image):    f = open(image)    img_raw_data = f.read()    f.close()    img_b64_string = base64.b64encode(img_raw_data)    convert_img_raw_data = base64.b64decode(img_b64_string)    t = open(&quot;example.png&quot;, &quot;w+&quot;)    t.write(convert_img_raw_data)    t.close()if __name__ == &quot;__main__&quot;:    convert(&quot;test.png&quot;)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用base64 对图片文件的编码和解码处理&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://blog.leezc.cn/tags/python/"/>
    
      <category term="base64" scheme="https://blog.leezc.cn/tags/base64/"/>
    
  </entry>
  
  <entry>
    <title>python 根据字符串随机生成颜色</title>
    <link href="https://blog.leezc.cn/posts/2019-12-28-38278.html"/>
    <id>https://blog.leezc.cn/posts/2019-12-28-38278.html</id>
    <published>2019-12-28T19:02:03.000Z</published>
    <updated>2019-12-28T19:02:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>遇到这么一个需求：根据用户名或用户id，随机生成一个颜色。其实就是用python 根据字符串随机生成颜色。</p><a id="more"></a><h2 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h2><p>下面是python 实现。</p><pre><code class="python">import hashlibdef hsv2rgb(h, s, v):    h += 0.618033988749895    h %= 1    h_i = int(h*6)    f = h*6 - h_i    p = v * (1 - s)    q = v * (1 - f*s)    t = v * (1 - (1 - f) * s)    if h_i == 0:        r, g, b = v, t, p    elif h_i == 1:        r, g, b = q, v, p    elif h_i == 2:        r, g, b = p, v, t    elif h_i == 3:        r, g, b = p, q, v    elif h_i == 4:        r, g, b = t, p, v    elif h_i == 5:        r, g, b = v, p, q    else:        r = g = b = 0    return [int(r*256), int(g*256), int(b*256)]def str2rgb(obj):    digest = hashlib.sha384(str(obj).encode(&#39;utf-8&#39;)).hexdigest()    sub_size = int(len(digest) / 3)    max_value = float(int(&quot;f&quot; * sub_size, 16))    digests = [digest[i * sub_size: (i + 1) * sub_size] for i in range(3)]    rgb = (((int(d, 16) / max_value)+0.618033988749895) % 1 for d in digests)    return &#39;#&#39; + &#39;&#39;.join([&quot;%02x&quot; % int(c*255 + 0.5 - 0.0000005) for c in rgb])def str2rgb2(obj):    digest = hashlib.sha384(str(obj).encode(&#39;utf-8&#39;)).hexdigest()    obj_value = int(digest, 16)    max_value = float(int(&quot;f&quot; * len(digest), 16))    rgb = hsv2rgb(obj_value/max_value, 0.5, 0.95)    return &#39;#&#39; + &#39;&#39;.join([&quot;%02x&quot; % c for c in rgb])</code></pre><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>上面有两种实现，其效果如下：<br><img src="/images/posts/str2rgb.png" alt="str2rgb.png"><br><img src="/images/posts/str2rgb2.png" alt="str2rgb2.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>第一种颜色较深，只要传入字符串不同，其颜色就不同。</li><li>第二种颜色较淡，过渡自然，但第二种只有732 种颜色。</li></ul><p>如果为了不同的颜色就使用第一种，如果允许相同的颜色，又要求柔和、自然接近，就考虑第二种。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遇到这么一个需求：根据用户名或用户id，随机生成一个颜色。其实就是用python 根据字符串随机生成颜色。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://blog.leezc.cn/tags/python/"/>
    
      <category term="字符串" scheme="https://blog.leezc.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="随机" scheme="https://blog.leezc.cn/tags/%E9%9A%8F%E6%9C%BA/"/>
    
      <category term="颜色" scheme="https://blog.leezc.cn/tags/%E9%A2%9C%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>python获取当前运行文件路径的方法</title>
    <link href="https://blog.leezc.cn/posts/2019-12-28-18016.html"/>
    <id>https://blog.leezc.cn/posts/2019-12-28-18016.html</id>
    <published>2019-12-28T17:48:32.000Z</published>
    <updated>2019-12-28T17:48:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>下面是python获取当前运行文件路径的方法</p><a id="more"></a><h2 id="通过-file-获取"><a href="#通过-file-获取" class="headerlink" title="通过 file 获取"></a>通过 <strong>file</strong> 获取</h2><pre><code>os.path.dirname(os.path.realpath(__file__))</code></pre><h2 id="通过-getcwd-获取当前路径"><a href="#通过-getcwd-获取当前路径" class="headerlink" title="通过 getcwd 获取当前路径"></a>通过 getcwd 获取当前路径</h2><pre><code>os.getcwd()</code></pre><p>更详细的 path 文档 <a href="https://docs.python.org/2/library/os.path.html" target="_blank" rel="noopener">https://docs.python.org/2/library/os.path.html</a></p><h2 id="其它相关路径"><a href="#其它相关路径" class="headerlink" title="其它相关路径"></a>其它相关路径</h2><pre><code>#当前文件路径print(os.path.realpath(__file__))#当前文件所在的目录，即父路径print(os.path.split(os.path.realpath(__file__))[0])#找到父路径下的其他文件，即同级的其他文件print(os.path.join(proDir,&quot;config.ini&quot;))</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面是python获取当前运行文件路径的方法&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://blog.leezc.cn/tags/python/"/>
    
      <category term="文件路径" scheme="https://blog.leezc.cn/tags/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>python PIL 生成图片验证码</title>
    <link href="https://blog.leezc.cn/posts/2019-12-28-63494.html"/>
    <id>https://blog.leezc.cn/posts/2019-12-28-63494.html</id>
    <published>2019-12-28T15:57:55.000Z</published>
    <updated>2019-12-28T15:57:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>下面是一个用python PIL 生成验证码的函数。</p><a id="more"></a><p>过程是：创建一张有底色的图片、在背景上添加杂色、写上特定文字、保存图片</p><pre><code># -*- coding: utf-8 -*-import randomimport Imageimport ImageFontimport ImageDrawimport ImageFilterdef gen_captcha(text, fnt, fnt_sz, file_name, fmt=&#39;JPEG&#39;):    # 随机生成背景色    fgcolor = random.randint(0,0xffff00)    bgcolor = fgcolor ^ 0xffffff    # 生成文字    font = ImageFont.truetype(fnt,fnt_sz)    dim = font.getsize(text)    im = Image.new(&#39;RGB&#39;, (dim[0]+5,dim[1]+5), bgcolor)    d = ImageDraw.Draw(im)    x, y = im.size    r = random.randint    # 给背景添加杂色    for num in range(100):        d.rectangle((r(0,x), r(0,y), r(0,x), r(0,y)), fill=r(0, 0xffffff))    # 添加文字    d.text((3,3), text, font=font, fill=fgcolor)    im = im.filter(ImageFilter.EDGE_ENHANCE_MORE)    im.save(file_name, format=fmt)def gen_random_word(wordLen=6):    allowedChars = &quot;abcdefghijklmnopqrstuvwzyzABCDEFGHIJKLMNOPQRSTUVWZYZ0123456789&quot;    word = &quot;&quot;    for i in range(0, wordLen):        word = word + allowedChars[random.randint(0,0xffffff) % len(allowedChars)]    return wordif __name__ == &#39;__main__&#39;:    word = gen_random_word()    print word    gen_captcha(word.strip(), &#39;porkys.ttf&#39;, 65, &quot;test.jpg&quot;)</code></pre><h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><p>一般情况不会要求填写验证码，避免影响用户体验。在特定情况下，如当用户登录密码出错N 次后，当用户频繁发贴时。</p><p>可对验证码作更复杂的变换，当用户输入验证码出错次数为N 时，增加其难度，如增加字符集、变化字体等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面是一个用python PIL 生成验证码的函数。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://blog.leezc.cn/tags/python/"/>
    
      <category term="PIL" scheme="https://blog.leezc.cn/tags/PIL/"/>
    
      <category term="验证码" scheme="https://blog.leezc.cn/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>用python 正确计算大文件md5 值</title>
    <link href="https://blog.leezc.cn/posts/2019-12-28-4278.html"/>
    <id>https://blog.leezc.cn/posts/2019-12-28-4278.html</id>
    <published>2019-12-28T15:52:25.000Z</published>
    <updated>2019-12-28T15:52:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>python 计算文件的md5值很方便，但如果只是简单的把文件都入到内存中，大文件会导致问题，一般采用切片的方式分段计算，下面的几个函数可以很好的解决这个问题。</p><a id="more"></a><h2 id="使用-hashlib"><a href="#使用-hashlib" class="headerlink" title="使用 hashlib"></a>使用 hashlib</h2><pre><code>import hashlibdef md5_for_file(f, block_size=2**20):    md5 = hashlib.md5()    while True:        data = f.read(block_size)        if not data:            break        md5.update(data)    return md5.digest()def md5sum(filename, blocksize=65536):    hash = hashlib.md5()    with open(filename, &quot;r+b&quot;) as f:        for block in iter(lambda: f.read(blocksize), &quot;&quot;):            hash.update(block)    return hash.hexdigest()</code></pre><h2 id="使用-Crypto-Hash"><a href="#使用-Crypto-Hash" class="headerlink" title="使用 Crypto.Hash"></a>使用 Crypto.Hash</h2><pre><code>import osfrom Crypto.Hash import MD5def get_file_checksum(filename):    h = MD5.new()    chunk_size = 8192    with open(filename, &#39;rb&#39;) as f:        while True:            chunk = f.read(chunk_size)            if len(chunk) == 0:                break            h.update(chunk)    return h.hexdigest()</code></pre><p>上面三个函数都能正确计算大文件md5 值</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python 计算文件的md5值很方便，但如果只是简单的把文件都入到内存中，大文件会导致问题，一般采用切片的方式分段计算，下面的几个函数可以很好的解决这个问题。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://blog.leezc.cn/tags/python/"/>
    
      <category term="md5" scheme="https://blog.leezc.cn/tags/md5/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://blog.leezc.cn/posts/2019-12-24-16107.html"/>
    <id>https://blog.leezc.cn/posts/2019-12-24-16107.html</id>
    <published>2019-12-24T18:44:19.000Z</published>
    <updated>2019-12-24T18:44:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>基于Hexo编写的轻巧简洁小清新博客。</p><a id="more"></a><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于Hexo编写的轻巧简洁小清新博客。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="https://blog.leezc.cn/tags/hexo/"/>
    
      <category term="install" scheme="https://blog.leezc.cn/tags/install/"/>
    
      <category term="nodeJS" scheme="https://blog.leezc.cn/tags/nodeJS/"/>
    
  </entry>
  
  <entry>
    <title>python form-data post上传数据简便方法</title>
    <link href="https://blog.leezc.cn/posts/2019-12-24-54485.html"/>
    <id>https://blog.leezc.cn/posts/2019-12-24-54485.html</id>
    <published>2019-12-24T17:59:16.000Z</published>
    <updated>2019-12-24T17:59:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时要用到 form-data 这种形式post 上传文件到服务器，下面介绍使用python 实现的简便方法。</p><a id="more"></a><p><img src="/images/posts/python-formdata-post.jpg" alt="python-formdata-post"></p><h2 id="方法一，使用-urllib2-自己打包"><a href="#方法一，使用-urllib2-自己打包" class="headerlink" title="方法一，使用 urllib2 自己打包"></a>方法一，使用 urllib2 自己打包</h2><p>自己封装form-data 也很方便</p><pre><code>def test():    #boundary只要是随机不同的就行    boundary = &#39;----------%s&#39; % hex(int(time.time() * 1000))    data = []    data.append(&#39;--%s&#39; % boundary)    fr=open(r&#39;test2.jpg&#39;,&#39;rb&#39;)    data.append(&#39;Content-Disposition: form-data; name=&quot;%s&quot;; filename=&quot;new_test2.jpg&quot;&#39; % &#39;file&#39;)    data.append(&#39;Content-Type: %s\r\n&#39; % &#39;image/jpeg&#39;)    data.append(fr.read())    fr.close()    data.append(&#39;--%s--\r\n&#39; % boundary)    #http_url=&#39;http://remotserver.com/page.php&#39;    http_url = &#39;http://xxx/v1/upload&#39;    http_body=&#39;\r\n&#39;.join(data)    try:        #buld http request        req=urllib2.Request(http_url, data=http_body)        #header        req.add_header(&#39;Content-Type&#39;, &#39;multipart/form-data; boundary=%s&#39; % boundary)#最重要的一行        #post data to server        resp = urllib2.urlopen(req, timeout=5)        #get response        qrcont=resp.read()        print qrcont    except Exception,e:        print &#39;http error&#39;</code></pre><h2 id="方法二，使用request"><a href="#方法二，使用request" class="headerlink" title="方法二，使用request"></a>方法二，使用request</h2><p>更简洁</p><pre><code>import requestsurl = &#39;xxx&#39;files={&#39;file&#39;:(&#39;newname.jpg&#39;,open(&#39;localname.jpg&#39;,&#39;rb&#39;),&#39;image/jpeg&#39;)}rsp=requests.post(url,files=files)print(rsp.request.text)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时要用到 form-data 这种形式post 上传文件到服务器，下面介绍使用python 实现的简便方法。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://blog.leezc.cn/tags/python/"/>
    
      <category term="form" scheme="https://blog.leezc.cn/tags/form/"/>
    
      <category term="data" scheme="https://blog.leezc.cn/tags/data/"/>
    
      <category term="post" scheme="https://blog.leezc.cn/tags/post/"/>
    
      <category term="上传" scheme="https://blog.leezc.cn/tags/%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>用SSH 密钥登录VPS</title>
    <link href="https://blog.leezc.cn/posts/2019-12-24-16726.html"/>
    <id>https://blog.leezc.cn/posts/2019-12-24-16726.html</id>
    <published>2019-12-24T17:45:13.000Z</published>
    <updated>2019-12-24T17:45:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>以前没有在VPS 上部署重要的东西，设置一个稍复杂的密码就可以。下面对记录一下VPS 禁止用户名+密码登录，仅使用密钥登录的过程。</p><a id="more"></a><p><img src="/images/posts/SSH%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95VPS.jpg" alt="SSH密钥登录VPS"></p><h2 id="生成SSH-公钥"><a href="#生成SSH-公钥" class="headerlink" title="生成SSH 公钥"></a>生成SSH 公钥</h2><p>确认是否已经有一个公钥，即检查<code>.ssh</code>文件夹，以及文件夹中是否存在<code>id_rsa</code> 和 <code>id_rsa.pub</code>文件，有.pub后缀的文件就是公钥，另一个文件则是密钥。如果不存在，或者干脆连<code>.ssh</code>文件夹都没有，可以进行创建。如果存在，就直接把<code>id_rsa.pub</code>内容输出，粘贴的服务器的相关文件。</p><pre><code>$ cd ~/.ssh$ ls</code></pre><p>可以用<code>ssh-keygen</code>来创建<br>默认公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空。</p><h2 id="更改VPS-sshd-配置"><a href="#更改VPS-sshd-配置" class="headerlink" title="更改VPS sshd 配置"></a>更改VPS sshd 配置</h2><p>编辑sshd 配置文件 <code>/etc/ssh/sshd_config</code><br>找到并修改为下面的样子：</p><pre><code>RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile      %h/.ssh/authorized_keysPasswordAuthentication no</code></pre><h3 id="添加公钥"><a href="#添加公钥" class="headerlink" title="添加公钥"></a>添加公钥</h3><p>打开文件<code>~/.ssh/authorized_keys</code>， 把本地的<code>id_rsa.pub</code> 内容粘贴到里面，保存退出</p><h3 id="重启sshd-服务"><a href="#重启sshd-服务" class="headerlink" title="重启sshd 服务"></a>重启sshd 服务</h3><pre><code>service sshd restart</code></pre><h2 id="其它安全措施"><a href="#其它安全措施" class="headerlink" title="其它安全措施"></a>其它安全措施</h2><p>上面所说的登录方式只是最基本的安全措施，还有比如更改ssh 默认端口、禁止root用户登录、使用denyhosts、启用iptables限制等等。</p><p>查看尝试暴力破解机器密码的人</p><pre><code>grep &quot;Failed password for root&quot; /var/log/auth.log | awk &#39;{print $11}&#39; | sort | uniq -c | sort -nr | more</code></pre><h2 id="查看成功登录信息"><a href="#查看成功登录信息" class="headerlink" title="查看成功登录信息"></a>查看成功登录信息</h2><pre><code>查看当前登录用户信息who命令：who缺省输出包括用户名、终端类型、登陆日期以及远程主机。who /var/log/wtmplastlast 用户名last -t 20181206160404显示这个时间戳之前的登陆历史</code></pre><h2 id="客户端密钥备份"><a href="#客户端密钥备份" class="headerlink" title="客户端密钥备份"></a>客户端密钥备份</h2><p>如果电脑重装了，就很难登录服务器，可以备份密钥，直接复制<code>id_rsa</code>、<code>id_rsa.pub</code>两个文件。当电脑重装或者想在其他电脑上登录主机，直接把这两个文件复制到 <code>~/.ssh/</code> 目录下就行。<br>如果使用备份的<code>id_rsa</code> 文件出现下面的错误提示</p><pre><code>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0644 for &#39;id_rsa&#39; are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored.</code></pre><p>可以用更改文件属性的方法来解决</p><pre><code>chmod 0600 id_rsa</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前没有在VPS 上部署重要的东西，设置一个稍复杂的密码就可以。下面对记录一下VPS 禁止用户名+密码登录，仅使用密钥登录的过程。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="VPS" scheme="https://blog.leezc.cn/tags/VPS/"/>
    
      <category term="SSH" scheme="https://blog.leezc.cn/tags/SSH/"/>
    
      <category term="密钥" scheme="https://blog.leezc.cn/tags/%E5%AF%86%E9%92%A5/"/>
    
      <category term="登录" scheme="https://blog.leezc.cn/tags/%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>OpenSSL 生成自签名证书备忘</title>
    <link href="https://blog.leezc.cn/posts/2019-12-24-63828.html"/>
    <id>https://blog.leezc.cn/posts/2019-12-24-63828.html</id>
    <published>2019-12-24T17:37:51.000Z</published>
    <updated>2019-12-24T17:37:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>用 OpenSSL 生成自签名证书的步骤：</p><a id="more"></a><p><img src="/images/posts/OpenSSL.jpg" alt="OpenSSL"></p><ul><li>创建Key； </li><li>创建签名请求；</li><li>将Key的口令移除；</li><li>用Key签名证书。<br>为HTTPS准备的证书需要注意，创建的签名请求的CN必须与域名完全一致，否则无法通过浏览器验证。<br>具体命令如下，把域名改为自己的域名：<pre><code>openssl genrsa -des3 -out $DOMAIN.key 1024openssl req -new -subj &quot;/C=US/ST=Mars/L=iTranswarp/O=iTranswarp/OU=iTranswarp/CN=$DOMAIN&quot; -key $DOMAIN.key -out $DOMAIN.csrmv $DOMAIN.key $DOMAIN.origin.keyopenssl rsa -in $DOMAIN.origin.key -out $DOMAIN.keyopenssl x509 -req -days 3650 -in $DOMAIN.csr -signkey $DOMAIN.key -out $DOMAIN.crt</code></pre>有时需要下面两个文件名更加方便识别：<pre><code>cp $DOMAIN.crt cert.pemcp $DOMAIN.key key.pem</code></pre>nginx 配置：<pre><code>ssl_certificate     $DOMAIN.crt;ssl_certificate_key $DOMAIN.key;</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用 OpenSSL 生成自签名证书的步骤：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="OpenSSL" scheme="https://blog.leezc.cn/tags/OpenSSL/"/>
    
      <category term="证书" scheme="https://blog.leezc.cn/tags/%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Mac pip2 与 pip3 共存</title>
    <link href="https://blog.leezc.cn/posts/2019-12-24-6349.html"/>
    <id>https://blog.leezc.cn/posts/2019-12-24-6349.html</id>
    <published>2019-12-24T17:31:16.000Z</published>
    <updated>2019-12-24T17:31:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mac 上的 pip2 与 pip3 共存笔记</p><a id="more"></a><p><img src="/images/posts/pip2-pip3.jpg" alt="pip2-pip3"><br>这里不想启用<code>pyenv</code><br>下载 <code>get-pip.py</code></p><pre><code>curl -O https://bootstrap.pypa.io/get-pip.py</code></pre><p>首先安装pip （pip2）</p><pre><code>sudo python2 get-pip.py</code></pre><p>再安装 <code>pip3</code></p><pre><code>sudo python3 get-pip.py</code></pre><p>测试：</p><pre><code>$ pip -Vpip 18.1 from /Library/Python/2.7/site-packages/pip-18.1-py2.7.egg/pip (python 2.7)$ pip2 -Vpip 18.1 from /Library/Python/2.7/site-packages/pip-18.1-py2.7.egg/pip (python 2.7)$ pip3 -Vpip 18.1 from /usr/local/lib/python3.6/site-packages/pip (python 3.6)</code></pre><p>如果失败就动用 <code>easy_install</code> 来安装：</p><pre><code>sudo easy_install pip</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mac 上的 pip2 与 pip3 共存笔记&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Mac" scheme="https://blog.leezc.cn/tags/Mac/"/>
    
      <category term="pip2" scheme="https://blog.leezc.cn/tags/pip2/"/>
    
      <category term="pip3" scheme="https://blog.leezc.cn/tags/pip3/"/>
    
  </entry>
  
  <entry>
    <title>OpenWrt 国内源</title>
    <link href="https://blog.leezc.cn/posts/2019-12-24-11985.html"/>
    <id>https://blog.leezc.cn/posts/2019-12-24-11985.html</id>
    <published>2019-12-24T16:37:18.000Z</published>
    <updated>2019-12-24T16:37:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>国内可用 OpenWrt 镜像</p><a id="more"></a><ul><li><a href="https://mirrors.ustc.edu.cn/lede/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/lede/</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/openwrt/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/openwrt/</a> 只更新到 chaos_calmer/15.05.1/</li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/lede/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/lede/</a> openwrt 最新版</li></ul><p>官方网站推荐的其他镜像</p><ul><li><a href="https://openwrt.org/downloads#mirrors" target="_blank" rel="noopener">https://openwrt.org/downloads#mirrors</a></li></ul><p>修改文件 <code>/etc/opkg/distfeeds.conf</code><br><img src="/images/posts/OpenWrt.png" alt="OpenWrt"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;国内可用 OpenWrt 镜像&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="OpenWrt" scheme="https://blog.leezc.cn/tags/OpenWrt/"/>
    
      <category term="国内" scheme="https://blog.leezc.cn/tags/%E5%9B%BD%E5%86%85/"/>
    
  </entry>
  
  <entry>
    <title>开启BBR 加速小VPS访问速度</title>
    <link href="https://blog.leezc.cn/posts/2019-12-24-27787.html"/>
    <id>https://blog.leezc.cn/posts/2019-12-24-27787.html</id>
    <published>2019-12-24T16:28:45.000Z</published>
    <updated>2019-12-24T16:28:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>TCP BBR 是 Google 开发的新的拥塞控制算法，据说是用在 YouTube 上，后来开源并且已经集成到 Linux 4.9-rc8 之后版本的内核中。它可以极大提高网络速度，大大降低延迟。</p><a id="more"></a><p>加速效果如下图所示：<br><img src="/images/posts/open-BBR.gif" alt="open-BBR"><br>如果你的 VPS 使用的是 OpenVZ 的虚拟技术，你是不能使用 BBR 的。并且系统要求在 CentOS 6+，Debian 7+，Ubuntu 12+。<br>对于4.9+的内核，默认编译了 TCP BBR 的内容，可以直接通过参数开启<br>uname -r 看看是不是内核 &gt;= 4.9<br>执行 <code>lsmod | grep bbr</code> ，如果结果中没有 <code>tcp_bbr</code> 的话就先执行</p><pre><code>modprobe tcp_bbrecho &quot;tcp_bbr&quot; &gt;&gt; /etc/modules-load.d/modules.conf</code></pre><p>执行</p><pre><code>echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.confecho &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</code></pre><p>保存生效</p><pre><code>sysctl -p</code></pre><p>执行</p><pre><code>sysctl net.ipv4.tcp_available_congestion_controlsysctl net.ipv4.tcp_congestion_control</code></pre><p>如果结果都有bbr, 则证明你的内核已开启bbr</p><p>看到有 tcp_bbr 模块即说明bbr已启动</p><p>再实行 <code>lsmod | grep bbr</code>，显示以下即启动成功：</p><pre><code>lsmod | grep bbrtcp_bbr                20480  14</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP BBR 是 Google 开发的新的拥塞控制算法，据说是用在 YouTube 上，后来开源并且已经集成到 Linux 4.9-rc8 之后版本的内核中。它可以极大提高网络速度，大大降低延迟。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="BBR" scheme="https://blog.leezc.cn/tags/BBR/"/>
    
      <category term="开启" scheme="https://blog.leezc.cn/tags/%E5%BC%80%E5%90%AF/"/>
    
      <category term="访问速度" scheme="https://blog.leezc.cn/tags/%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6/"/>
    
      <category term="VPS" scheme="https://blog.leezc.cn/tags/VPS/"/>
    
      <category term="加速" scheme="https://blog.leezc.cn/tags/%E5%8A%A0%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>Openwrt 路由上开启BBR</title>
    <link href="https://blog.leezc.cn/posts/2019-12-24-46437.html"/>
    <id>https://blog.leezc.cn/posts/2019-12-24-46437.html</id>
    <published>2019-12-24T14:24:02.000Z</published>
    <updated>2019-12-24T14:24:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>BBR 是一种协议算法，在 Openwrt 路由上启用 BBR 还是有一定作用的。 Openwrt 18.* 后都自带模块 <code>kmod-tcp-bbr</code> 安装就可以。</p><a id="more"></a><p><img src="/images/posts/Openwrt-BBR.jpg" alt="Openwrt-BBR"><br>看内核版本</p><pre><code>root@OpenWrt:~# uname -r4.9.184</code></pre><p>安装 <code>kmod-tcp-bbr</code></p><pre><code>opkg updateopkg install kmod-tcp-bbr</code></pre><p>会安装相关的 ipk</p><pre><code>Configuring kmod-sched-core.Configuring kmod-sched.Configuring kmod-tcp-bbr.</code></pre><p>查看相关情况</p><pre><code>root@OpenWrt:~# sysctl net.ipv4.tcp_congestion_controlnet.ipv4.tcp_congestion_control = cubicroot@OpenWrt:~# sysctl net.ipv4.tcp_available_congestion_controlnet.ipv4.tcp_available_congestion_control = cubic reno bbrroot@OpenWrt:~# sysctl net.core.default_qdiscnet.core.default_qdisc = fq_codelroot@OpenWrt:~# lsmod | grep bbrtcp_bbr                 4832  0root@OpenWrt:~# cat /etc/sysctl.conf# Defaults are configured in /etc/sysctl.d/* and can be customized in this fileroot@OpenWrt:~# ls -l /etc/sysctl.d/-rw-r--r--    1 root     root           675 Jun 27 12:18 10-default.conf-rw-r--r--    1 root     root           379 Jun 27 12:18 11-nf-conntrack.conf-rw-r--r--    1 root     root           184 Jun 27 12:18 12-tcp-bbr.confroot@OpenWrt:~# cat /etc/sysctl.d/12-tcp-bbr.conf# Do not edit, changes to this file will be lost on upgrades# /etc/sysctl.conf can be used to customize sysctl settingsnet.ipv4.tcp_congestion_control=bbrnet.core.default_qdisc=fqroot@OpenWrt:~# sysctl -proot@OpenWrt:~# lsmod | grep bbrtcp_bbr                 4832  0</code></pre><p>还没生效，重启路由后再看看</p><pre><code>root@OpenWrt:~# lsmod | grep bbrtcp_bbr                 4832 21root@OpenWrt:~# sysctl net.ipv4.tcp_congestion_controlnet.ipv4.tcp_congestion_control = bbr</code></pre><p>BBR 加速生效了！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BBR 是一种协议算法，在 Openwrt 路由上启用 BBR 还是有一定作用的。 Openwrt 18.* 后都自带模块 &lt;code&gt;kmod-tcp-bbr&lt;/code&gt; 安装就可以。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="OpenWrt" scheme="https://blog.leezc.cn/tags/OpenWrt/"/>
    
      <category term="BBR" scheme="https://blog.leezc.cn/tags/BBR/"/>
    
      <category term="路由" scheme="https://blog.leezc.cn/tags/%E8%B7%AF%E7%94%B1/"/>
    
      <category term="开启" scheme="https://blog.leezc.cn/tags/%E5%BC%80%E5%90%AF/"/>
    
  </entry>
  
  <entry>
    <title>Vim 与中文输入法</title>
    <link href="https://blog.leezc.cn/posts/2019-12-21-21047.html"/>
    <id>https://blog.leezc.cn/posts/2019-12-21-21047.html</id>
    <published>2019-12-21T00:18:44.000Z</published>
    <updated>2019-12-21T00:18:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>我最后还是放弃把 Vim 作为主要编辑器来输入中文了，整体使用下来 mental model 的 cost 太重了。<a id="more"></a>记笔记时用用中文呀或者改改博客时偶尔用一下还<br>蛮去，这个时候这个功能至少能帮助你 Esc 之后不煞笔，所以也不算完全没有价值吧……</p><hr><p>我相信很多中文世界的 Vimer 都遇到过这个烦恼，在 vim 的 insert 模式时可能突然想输个中文，输完之后会本能的直接 <code>esc</code> 接 normal 模式操作，结果发现<br>跳出来的是中文输入法……对于 vscode，我一般会在几次错误之后被逼到退出 vscode vim 模式，而对于终端中用的 neovim，就只能尽量不输入中文了。</p><p>为了满足我 1% 用 vim 输入中文的场景（比如写博客），我还是想看看有没有什么解决方案，Google 出来的解决方案基本是：<em>在退出 insert 模式时记住当时的<br>输入法，并自动切换到默认输入法（一般是英文）给 normal 模式用，并且在下一次进入 insert 模式时再切换回来。</em></p><p>原生 vim 的话，可以使用 <a href="https://github.com/ybian/smartim" target="_blank" rel="noopener">smartim</a> 插件，原理是调用 <a href="https://github.com/daipeihust/im-select" target="_blank" rel="noopener">im-select</a> 这个 CLI 工具来切换输入法。</p><p>对于 VSCode-vim 的话，smartim 的移植也在近期的 PR 中被 merge 到了插件里，<a href="https://github.com/VSCodeVim/Vim#use-im-select" target="_blank" rel="noopener">详情见文档的这部分配置</a>，需要指定一下默认输入法和 im-select 的 binary 路径就好。</p><hr><p>不过实话说，在 vim 中编辑中文的效率和体验和英文比都是大打折扣的。因为中文分词难度太高，不像英文可以简单依靠一个 <code>split &quot; &quot;</code> 搞定。所以其实无论 vim（<code>w</code>ord，<code>b</code>egin，<code>e</code>nd），emacs 还是操作系统自带的（比如 macOS 中的 <code>alt + 箭头</code>） 「按词移动」功能对于中文都仅仅是跳转到下一个空格处而已&gt;，对于中文来说基本就是下一句了……其他常用操作诸如 <code>f</code>，<code>/</code>, <code>r</code>eplace, <code>t</code>ill 也都无法很好的工作，基本只能靠 <code>hjkl</code> 爬行……</p><p>不过也算聊胜于无吧，由于我的主力外置键盘是 HHKB，能用 vim 操作的一个子集（<code>hjkl</code>, <code>o</code>, <code>A</code>, <code>I</code>, <code>v</code> etc.）可能也比按住 <code>Fn</code> 的方向键好用……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我最后还是放弃把 Vim 作为主要编辑器来输入中文了，整体使用下来 mental model 的 cost 太重了。
    
    </summary>
    
    
    
      <category term="Vim" scheme="https://blog.leezc.cn/tags/Vim/"/>
    
      <category term="Linux" scheme="https://blog.leezc.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Markdown插入图片、视频和公式</title>
    <link href="https://blog.leezc.cn/posts/2019-12-20-33346.html"/>
    <id>https://blog.leezc.cn/posts/2019-12-20-33346.html</id>
    <published>2019-12-20T22:58:21.000Z</published>
    <updated>2019-12-20T22:58:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些常用的Markdown插入图片和视频方法</p><a id="more"></a><h2 id="1-Markdown-插入图片的几种方法"><a href="#1-Markdown-插入图片的几种方法" class="headerlink" title="1. Markdown 插入图片的几种方法"></a>1. Markdown 插入图片的几种方法</h2><h3 id="1-1-原-markdown-语法"><a href="#1-1-原-markdown-语法" class="headerlink" title="1.1 原 markdown 语法"></a>1.1 原 markdown 语法</h3><pre><code class="markdown">![这是图片描述](这是图片链接)</code></pre><h3 id="1-2-html-语法"><a href="#1-2-html-语法" class="headerlink" title="1.2 html 语法"></a>1.2 html 语法</h3><pre><code class="html">&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/shw2018/cdn/master/blog_files/img/PicGo-Github-PicBed/2.png&quot; &gt;&lt;/p&gt;</code></pre><h2 id="2-插入音乐-以网易云音乐为例"><a href="#2-插入音乐-以网易云音乐为例" class="headerlink" title="2. 插入音乐,以网易云音乐为例"></a>2. 插入音乐,以网易云音乐为例</h2><p>例1：</p><pre><code class="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=450 src=&quot;//music.163.com/outchain/player?type=0&amp;id=2737308121&amp;auto=1&amp;height=430&quot;&gt;&lt;/iframe&gt;</code></pre><p>效果：</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=450 src="//music.163.com/outchain/player?type=0&id=2737308121&auto=1&height=430"></iframe><h2 id="3-几种文章内视频插入的方法"><a href="#3-几种文章内视频插入的方法" class="headerlink" title="3. 几种文章内视频插入的方法"></a>3. 几种文章内视频插入的方法</h2><p>例1：</p><pre><code class="html">&lt;video width=&quot;100%&quot; height=100% src=&quot;https://yanghexo.cn-bj.ufileos.com/github.mp4&quot; controls=&quot;controls&quot; poster=&quot;https://yanghexo.cn-bj.ufileos.com/github.jpg&quot; preload=&quot;auto&quot;&gt; &lt;/video&gt;</code></pre><p>效果：</p><p><video width="100%" height=100% src="https://yanghexo.cn-bj.ufileos.com/github.mp4" controls="controls" poster="https://yanghexo.cn-bj.ufileos.com/github.jpg" preload="auto"> </video></p><p>例二：<br>需要先装一个插件：<code>npm install hexo-tag-dplayer --save</code></p><pre><code>{% dplayer "url=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.mp4" "addition=https://dplayer.daoapp.io/bilibili?aid=4157142" "api=https://api.prprpr.me/dplayer/" "pic=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.jpg" "id=9E2E3368B56CDBB4" "loop=yes" "theme=#FADFA3" "autoplay=false" "token=tokendemo" %} {% dplayer 'url=some.mp4' "id=someid" "api=https://api.prprpr.me/dplayer/" "addition=/some.json" 'code=player.on("loadstart",function(){console.log("loadstart")})' "autoplay" %}</code></pre><p>效果：</p><p>例三：</p><p>iframe内嵌哔哩哔哩视频播放</p><pre><code class="html">&lt;iframe width=&quot;100%&quot; height=&quot;100%&quot; src=&quot;//player.bilibili.com/player.html?aid=52012946&amp;cid=91055960&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;</code></pre><iframe width="100%" height="500px" src="//player.bilibili.com/player.html?aid=52012946&cid=91055960&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><hr><p>参数说明：</p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>autoplay</td><td><em>autoplay</em></td><td>如果出现该属性，则视频在就绪后马上播放。</td></tr><tr><td>controls</td><td><em>controls</em></td><td>如果出现该属性，则向用户显示控件，比如播放按钮。</td></tr><tr><td>width</td><td><em>pixels</em></td><td>设置视频播放器的宽度。</td></tr><tr><td>height</td><td><em>pixels</em></td><td>设置视频播放器的高度。</td></tr><tr><td>loop</td><td><em>loop</em></td><td>如果出现该属性，则当媒介文件完成播放后再次开始播放。</td></tr><tr><td>multed</td><td>_multed</td><td>如果出现该属性，视频的音频输出为静音。</td></tr><tr><td>poster</td><td><em>URL</em></td><td>规定视频正在下载时显示的图像，直到用户点击播放按钮。</td></tr><tr><td>srv</td><td><em>URL</em></td><td>要播放的视频的 URL。</td></tr><tr><td>preload</td><td><em>auto metadata none</em></td><td>如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td></tr></tbody></table><ul><li>例子：</li></ul><pre><code>$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，行内公式示例} $</code></pre><p>显示：<br>$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，行内公式示例} $</p><ul><li>例子：</li></ul><pre><code class="mathematical">$$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，独立公式示例} $$</code></pre><p>显示：<br>$$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \Gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，独立公式示例<br>} $$</p><ul><li>例子：</li></ul><pre><code class="mathematical">$$ f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right) $$</code></pre><p>显示：<br>$$ f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right) $$</p><ul><li>例子：</li></ul><pre><code class="mathematical">$$\frac{a-1}{b-1} \quad and \quad {a+1\over b+1}$$</code></pre><p>显示：<br>$$\frac{a-1}{b-1} \quad and \quad {a+1\over b+1}$$</p><p>例子：</p><pre><code class="mathematical">$$f(x_1,x_2,\underbrace{\ldots}_{\rm ldots} ,x_n) = x_1^2 + x_2^2 + \underbrace{\cdots}_{\rm cdots} + x_n^2$$</code></pre><p>显示：<br>$$f(x_1,x_2,\underbrace{\ldots}<em>{\rm ldots} ,x_n) = x_1^2 + x_2^2 + \underbrace{\cdots}</em>{\rm cdots} + x_n^2$$</p><p>例子：</p><pre><code class="mathematical">$$d = \sqrt{(x_2-x_1)^2+(y_2-y_1)^2},|X|=\sqrt{x_2^2+y_2^2}.$$</code></pre><p>显示：</p><p>$$<br>d = \sqrt{(x_2-x_1)^2+(y_2-y_1)^2},|X|=\sqrt{x_2^2+y_2^2}.<br>$$</p><p>例子：</p><pre><code class="mathematical">$$d = \sqrt{(x_2-x_1)^2+(y_2-y_1)^2+(z_2-z_1)^2},|X|=\sqrt{x_2^2+y_2^2+z_2^2}.$$</code></pre><p>显示：<br>$$<br>d = \sqrt{(x_2-x_1)^2+(y_2-y_1)^2+(z_2-z_1)^2},|X|=\sqrt{x_2^2+y_2^2+z_2^2}.<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些常用的Markdown插入图片和视频方法&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Markdown" scheme="https://blog.leezc.cn/tags/Markdown/"/>
    
      <category term="写作" scheme="https://blog.leezc.cn/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
</feed>
